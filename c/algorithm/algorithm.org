* 公式
1^2 + 2^2 + 3^2 + ... + N^2 = N(N+1)(2N+1)/6 约等于 N^3 / 3
1^k + 2^k + 3^k + ... + N^k 约等于 N^(k+1)/|k+1|, 其中k!=-1

证明: lgX < X 对所有的X>0成立.

当k=-1时, 该公式用的很多, Hn = (1+ 1/2 + 1/3 + 1/4 + 1/5 + ... + 1/N) 约等于 logeN
该值约等于: 0.57721566, 这个被称为欧拉常数.

公式的证明常用的是: 归纳法和反正法

* 题目
P9
1. i=0 -> 无穷 求1/4^i的和
2. i=0 -> 无穷 求i/4^i的和
3. i=0 -> 无穷 求i^2/4^i的和

* 空间复杂度
空间复杂度是指除了原本的数据存储空间外, 算法运行时还需要额外的存储空间

* 数据结构
** 数组
[[file:array.org][数组及其应用]]

** 链表
[[file:linklist.org][链表及其应用]]

** 栈
[[file:stack.org][栈及其应用]]

** 队列
[[file:queue.org][队列及其应用]]

* 递归
递归是一种应用非常广泛的算法.

** 递归需要满足的3个条件
1. 一个问题的解可以分解为几个子问题的解
   子问题就是数据规模更小的问题
2. 这个问题与分解之后的子问题, 除了数据规模不同, 求解思路完全一样
3. 存在递归终止条件

写递归代码的关键就是找到如何将大问题分解为小问题的规律, 并且基于此写出递推公式, 然后再推敲终止条件
最后将递推公式和终止条件翻译成代码.

理解递归的一种方法是:
如果一个问题A可以分解为若干子问题B、C、D, 你可以假设子问题B、C、D已经解决, 在此基础上思考如何解决
A问题. 而且只要需要思考问题A与子问题B、C、D两层之间的关系即可, 不需要一层层往下思考子问题与
子子问题之间的关系. 屏蔽掉递归的细节, 这样理解起来就简单多了.

因此: 编写递归代码的关键是, 只要遇到递归, 就把它抽象成一个递推公司, 不用想一层层的调用关系, 不要
试图用人脑去分解递归的每个步骤.

** 编写递归的基本法则
1. 基准情形
   必须总有某些基准情形, 它无须递归就能化解
2. 不断推进
   每次递归调用都必须要使求解状况朝接近基准情形的方向推进
3. 设计法则
   所有的递归调用都能运行
4. 合成效益法则
   在求解一个问题的同一实例时, 切勿在不同的递归调用中做重复性的工作.

** 递归注意事项
1. 递归代码需要警惕堆栈溢出.
2. 递归代码要警惕重复计算
   为了避免重复计算, 可以通过一个数据结构来保存已经求解过的f(k)

** 将递归代码改为非递归代码
递归代码表达能力强, 但空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用等问题.

* 深度优先搜索 - DFS
深度优先搜索的基本模型:
void dfs(int step) {
    判断边界条件
    尝试每一种可能 for (int i=0; i<n; i++) {
        继续下一步 dfs(step+1);
    }
    返回
}

** 深度优先搜索代码示例
[[file:code/numberpermutation.c][1~9之间的全排列]]

* 排序
** 排序算法的分析
对排序算法的分析, 可以从以下几个方面入手.
1. 最好、最坏、平均时间复杂度
2. 时间复杂度的系数、常数、低阶
   在实际的软件开发中, 排序的数据可能不多, 在对同一阶时间复杂度的排序算法性能对比的时候,
   就需要考虑.
3. 比较次数和交换(或移动)次数
   基于比较的排序算法的执行过程, 应该把比较次数和交换次数考虑进去
4. 排序算法的内存消耗
   即空间复杂度.
   原地排序: 特指空间复杂度是O(1)的排序算法.
5. 排序算法的稳定性
   如果待排序的序列中存在值相同的元素, 经过排序后, 相等元素之间原有的先后顺序不变. 这就是稳定
   的排序算法.

   稳定排序算法的一个用途:
   给交易系统的"订单"进行排序, 一个是下单时间, 一个是订单金额. 如果此时需要先按订单金额排序,
   金额相同是根据下单时间排序.
   借助稳定排序算法, 实现思路是: 先按订单时间排序, 排序之后的使用稳定的排序算法按照订单金额
   重新排序即可. 两遍排序之后得到的订单数据就符合要求了.

** 有序度与逆序度
有序度是数组中具有有序关系的元素对的个数. 有序元素对用数学表达式如下:
有序元素对: a[i] <= a[j], 如果i<j.
例如: 2, 4, 3, 1, 5, 6这组数据的有序度为11, 其有序元素对为11个, 分别是:
(2, 4), (2, 3), (2, 5), (2, 6)
(4, 5), (4, 6), (3, 5), (3, 6)
(1, 5), (1, 6), (5, 6)

同理对于一个倒序排列的数组, 其有序度是0.
完全有序的数组, 有序度就是n*(n-1)/2

将完全有序的数组的有序度叫做满有序度.
逆序度的定义与有序度相反(默认为从小到大为有序), 逆序元素对: a[i] > a[j], 如果i<j

逆序度 = 满有序度 - 有序度

** 具体的排序算法
冒泡排序包含两个操作原子, 比较和交换, 每交换一次有序度就+1, 不管算法如何改进, 交换次数总是确定的
即为逆序度, 即:n*(n-1)/2 - 初始有序度

插入排序: 将数组中的数据分为两个区间, 已排序区间和未排序区间. 初始已排序区间只有一个元素,即第一个
元素.
插入排序包含比较和移动操作, 对于一个给定的序列, 移动次数就是其逆序度.

选择排序的实现思路类似插入排序, 但选择排序每次会从未排序区间中找到最小的元素, 将其放到已排序区间
的末尾.

插入排序为什么比冒泡排序更受欢迎?
原因如下:
对于一个给定的序列, 冒泡排序不管如何优化, 元素的交换次数是固定的, 插入排序元素的移动次数也是固定
的. 但从代码实现上看, 冒泡排序的数据交换要比插入排序的数据移动复杂, 代码如下:
#+BEGIN_SRC c
// 冒泡排序中的数据交换
if (a[j] > a[j+1]) {
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
}

// 插入排序中数据的移动操纵
if(a[j] > value) {
    a[j+1] = a[j];
} else {
    break;
}
#+END_SRC

插入排序的算法思路有很大的优化空间, 例如: 希尔排序

** 归并排序 - Merge sort
用到了分治思想, 可以借用分治思想来解决非排序的问题. 如如何在O(n)时间复杂度内查找一个无序数组中
的第K大元素.

归并排序的思想如下: 把数组从中间分成前后两部分, 然后对前后两部分分别排序, 再将排好序的
两部分合并在一起, 这样整个数组就都有序了.

分治就是分而治之, 将一个大问题分解成小的子问题来解决.小问题解决了, 大问题也解决了.
分治算法一般都是用递归来实现的, 分治是一种解决问题的处理思想, 递归是一种编程技巧.

** 快速排序 - quick sort
快排利用的也是分治思想, 其思路完全不一样. 思路是: 如果要排序数组中下标从p到r之间的一组数据,
我们选择p到r之间的任意一个数据作为pivot(分区点). 遍历p到r之间的数据, 将小于pivot的放到左边,
大于pivot的放到右边, 将pivot放到中间. 根据分治与递归的处理思想, 可以用递归排序下标从p到q-1
和q+1到r之间的数据, 直到区间缩小为1.

当对有序的数据进行快速排序时, 时间复杂度会退化到O(n^2), 因此出现这种情况的主要原因是因为分区
点选的不够合理.

理想的分区点是: 被分区点分开的两个分区中, 数据的数量差不多.
比较常用和简单的分区算法
1. 三数取中法
   从区间的首、尾、中分别取一个数, 然后对比大小, 取这3个数的中间值作为分区点. 如果要排序的数组
   比较大, 可能需要5数取中或10数取中
2. 随机法
   每次从要排序的区间中, 随机选择一个元素作为分区点

快速排序是用递归来实现的, 需要注意堆栈溢出的问题. 解决方法:
1. 限制递归深度, 一旦递归过深, 超过了设定的阈值就停止递归
2. 通过在堆上模拟实现一个函数调用栈, 手动模拟递归压栈、出栈的过程, 这样就没有系统栈大小的限制.

** 快排与归并排序的对比
归并排序的处理过程是由下到上, 先处理子问题, 然后再合并. 快排相反是由上到下的, 先分区, 然后再
处理子问题.

** 求无序数组中的第K大元素
选择数组区间A[0...n-1]的最后一个元素A[n-1]作为pivot, 对数组A[0...n-1]原地分区, 这样数组就分成了
三部分, A[0...p-1], A[p], A[p+1...n-1]
如果p+1=K, 则A[p]就是要求解的元素, 如果K>p+1, 说明第K大元素出现在A[p+1...n-1]区间, 再按照递归
思路在A[p+1...n-1]这个区间内查找即可. 注意是倒序排列哦.

** 线性排序 - 根据年龄给100w用户数据排序
桶排序、计数排序、基数排序, 这些排序算法的时间复杂度是O(n). 之所以是线性的时间复杂度, 主要原因
是这三个算法是基于非比较的排序算法, 不涉及到元素之间的比较操作.

** 如何实现一个通用的、高效的排序函数
对于小规模的数据进行排序, 可以选择时间复杂度为O(n^2)的算法, 大规模的数据需要使用O(nlgn).

*** 桶排序
会用到"桶", 核心思想是将要排序的数据分到几个有序的桶里, 每个桶里的数据再单独进行排序. 每个桶
里的数据再单独进行排序. 桶内排序完成之后, 再把每个桶里的数据按照顺序依次取出, 组成的序列就是
有序的了.

时间复杂度分析:
如果要排序的数据有n个, 把它们均匀的划分到m个桶内, 每个桶里就有k=n/m个元素, 每个桶内部使用快速
排序, 时间复杂度为O(k*logk), m个桶排序的时间复杂度就是O(m*k*logk), 因为k=n/m, 当桶的个数接近
数据个数时, logn/m就是一个非常小的常理, 此时时间复杂度接近O(n).

桶排序算法对排序数据的要求很苛刻:
1. 要排序的数据需要很容易就能划分成m个桶, 且桶之间有着天然的大小顺序. 这样每个桶内的数据都排序
   完后, 桶之间的数据不需要再进行排序.
2. 数据在各个桶之间的分布是比较均匀的. 如果数据经过桶的划分之后, 在极端情况下, 如果数据都被划分
   到一个桶里, 那就退化为O(nlogn)的排序算法了.

桶排序比较适合用在外部排序中, 所谓的外部排序就是数据存储在外部磁盘中, 数据量比较大, 内存有限,
无法将数据全部加载到内存中.

例如对10GB的订单数据按订单金额排序, 解决思路:
1. 扫描一遍文件, 看订单金额所处的数据范围, 假设扫描后数据范围是1~10w元. 此时将所有订单根据金额
   划分到100个桶里, 第一个桶我们存储金额在1~1000元, 第2个桶金额在1001~2000.
   依次类推, 每个桶对应一个文件, 并且按照金额范围的大小顺序编号命名(00, 01, 02, ..., 99)
2. 理想情况下, 如果订单金额在1~10w之间均匀分布, 那订单就会被均匀划分到100个文件中, 每个文件中
   存储的大约为100M左右的数据, 此时可以将这个100个文件依次放到内存中, 用快排来排序.
   等所有文件都排好序之后, 只需要按照文件编号, 从小到大依次读取每个小文件中的订单数据, 并将其写
   入到一个文件中即可.
3. 如果某个区域的金额数据特别多, 划分之后对应的文件很大. 此时可以针对这些比较大的数据继续划分.
   一直到满足要求位置.

*** 计数排序
可以将计数排序理解为一种特殊的桶排序. 当要排序的n个数据所处的范围并不大的时候, 如最大值为K.
就可以把数据划分成K个桶, 每个桶内的数据值都是相同的, 省掉了桶内排序的时间.

计数排序只能用在数据范围不大的场景中, 如果数据范围k比要排序的数据n大很多, 就不适合用计数排序.
计数排序只能给非负整数排序, 如果要排序的数据是其他类型的, 要将其在不改变相对大小的情况下,
转化为非负整数.

以考生的分数举例来实现计数排序的稳定算法:
假设有8个考生, 分数在0~5之间, 成绩分别为: 2, 5, 3, 0, 2, 3, 0, 3
使用6个大小的数组C[6]表示桶, C[6]内存中存储的是对应分数的考生个数.
C[6] = {2, 0, 2, 3, 0, 1}
然后对C[6]数组顺序求和, C[6]={2, 2, 4, 7, 7, 8}
然后最重要的部分如下:
从后面依次扫描数组A, 当扫描到3时, 可以从数组C中取出下标为3的值即7, 即到目前为止, 包括自己在内
分数小于等于3的人数是7个, 即该3是新排序数组R中的第7个元素, 当3放入R中下标为6的位置后, 小于等于
3的元素就只剩下6个了, 所以C[3]要减1, 然后继续遍历.

从后往前遍历的原因是为了排序的稳定性.

*** 基数排序 - radix sort
假设有10w个手机号码, 希望将这10w个手机号码从小到大排列, 如何用O(n)时间做到.
此时用计数排序和桶排序都不太现实, 会占用大量的内存空间.

借助稳定排序算法, 先按最后一位来排序手机号码, 然后再按照倒数第二位重新排序, 最后按照第一位重新
排序, 经过11次排序之后, 手机号码就都有序了. 注意一定要从最低位开始排, 否则结果会不正确.

注意: 这里按照每位来排序的算法要是稳定的, 否则这个思路就是不正确的.
根据每位来排序, 就可以用桶排序或者计数排序. 总的时间复杂度是O(k*n), 当k不大的时候, 时间复杂度
就基本等于O(n).

有时候要排序的数据不是等长的, 可以使用补齐到相同长度.

基数排序对要排序的数据是有要求的, 需要可以分割出独立的"位"来比较, 而且位之间有递进的关系,
如果a数据的高位比b数据大, 那剩下的低位就不用比较了. 并且每位的数据范围不能太大, 要可以用线性
排序算法来排序, 否则基数排序的时间复杂度就无法做到O(n)了.

** 排序算法代码实现
[[file:code/bubblesort.c][冒泡排序算法]]
[[file:code/insertsort.c][插入排序算法]]
[[file:code/selectsort.c][选择排序算法]]
[[file:code/merge_sort.c][归并排序算法]]
[[file:code/quicksort.c][快速排序算法]]
[[file:code/nthlargest.c][第k大数据元素的实现 - 采用快排思想]]

** 快速排序 - 荷兰国旗问题
在使用partition-exchange排序算法时, 如快排, 当排序对象中有很多重复的元素时, partition-exchange
排序算法表现不尽入人意. 当所有元素都相同时, 这就很容易理解了. 为了解决这个问题, 该问题有时
也叫做荷兰国旗问题. 该问题是计算机科学中一个程序难题, 是由Edsger Dijkstra提出的.

问题描述:
荷兰国旗是由红、白、蓝三色组成的, 现有若干个红白蓝三种颜色的球随机排列成一条直线, 现在的任务是
把这些球按照红、白、蓝排序.

解决思路:
将其视为一个数组排序问题, 该数组分为前、中、后三个部分. 每个元素(红、白、蓝分别对应0,1,2)必属于
其中之一, 这三个区域不一定是等分的. 其解决思路是: 将前部和后部各排在数组的前边和后边, 中部自然
就排好了, 具体如下:
[[file:code/holandproblem.c][荷兰国旗问题]]

* 简单的数据结构
[[file:code/array_queue.c][数组实现的队列 - 顺序队列]]
[[file:code/array_stack.c][数组实现的栈 - 顺序栈]]
[[file:code/single_linklist.c][单链表的实现]]

* 查找
** 二分查找
简单的二分查找算法不难, 最简单的情况就是: 有序数组中不存在重复元素.
二分查找容易出错的3个地方:
1. 循环退出条件
2. mid的取值
   应该使用low + (high-low)/2来计算, 原因是(high+low)/2时, 加法可能会照成数据溢出
3. low和high的更新,

二分查找算法的适用场景:
1. 二分查找依赖的是顺序表结构, 即数组
2. 二分查找针对的是有序数组, 并且只能用在插入、删除操作步频繁, 一次排序多次查找的场景中.
   针对动态变化的数据集合, 二分查找将不再适用
3. 数据量太小不适合二分查找
   如果元素之间的比较操作比较耗时,不管数据量大小, 都推荐使用二分查找.
4. 数据量太大也不适合二分查找

** 二分查找的变形问题
比较典型的几个如下:
1. 查找第一个值等于给定值的元素
2. 查找最后一个值等于给定值的元素
3. 查找第一个大于等于给定值的元素
4. 查找最后一个小于等于给定值的元素

** 查找算法代码实现
[[file:code/bsearch.c][二分查找算法]]
[[file:code/bsearchfirst.c][查找第一个值等于给定值的元素]]
[[file:code/bsearchlast.c][查找最后一个值等于给定值的元素]]
[[file:code/bsearchfirstle.c][查找第一个大于等于给定值的元素]]
[[file:code/bsearchlastle.c][查找最后一个小于等于给定值的元素]]

* 其他问题
荷兰国旗问题
猴子排序
睡眠排序
面条排序
