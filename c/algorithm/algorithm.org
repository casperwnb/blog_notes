* 公式
1^2 + 2^2 + 3^2 + ... + N^2 = N(N+1)(2N+1)/6 约等于 N^3 / 3
1^k + 2^k + 3^k + ... + N^k 约等于 N^(k+1)/|k+1|, 其中k!=-1

证明: lgX < X 对所有的X>0成立.

当k=-1时, 该公式用的很多, Hn = (1+ 1/2 + 1/3 + 1/4 + 1/5 + ... + 1/N) 约等于 logeN
该值约等于: 0.57721566, 这个被称为欧拉常数.

公式的证明常用的是: 归纳法和反正法

* 题目
P9
1. i=0 -> 无穷 求1/4^i的和
2. i=0 -> 无穷 求i/4^i的和
3. i=0 -> 无穷 求i^2/4^i的和

* 空间复杂度
空间复杂度是指除了原本的数据存储空间外, 算法运行时还需要额外的存储空间

* 数据结构
** 数组
[[file:array.org][数组及其应用]]

** 链表
[[file:linklist.org][链表及其应用]]

** 栈
[[file:stack.org][栈及其应用]]

** 队列
[[file:queue.org][队列及其应用]]

* 递归
递归是一种应用非常广泛的算法.

** 递归需要满足的3个条件
1. 一个问题的解可以分解为几个子问题的解
   子问题就是数据规模更小的问题
2. 这个问题与分解之后的子问题, 除了数据规模不同, 求解思路完全一样
3. 存在递归终止条件

写递归代码的关键就是找到如何将大问题分解为小问题的规律, 并且基于此写出递推公式, 然后再推敲终止条件
最后将递推公式和终止条件翻译成代码.

理解递归的一种方法是:
如果一个问题A可以分解为若干子问题B、C、D, 你可以假设子问题B、C、D已经解决, 在此基础上思考如何解决
A问题. 而且只要需要思考问题A与子问题B、C、D两层之间的关系即可, 不需要一层层往下思考子问题与
子子问题之间的关系. 屏蔽掉递归的细节, 这样理解起来就简单多了.

因此: 编写递归代码的关键是, 只要遇到递归, 就把它抽象成一个递推公司, 不用想一层层的调用关系, 不要
试图用人脑去分解递归的每个步骤.

** 编写递归的基本法则
1. 基准情形
   必须总有某些基准情形, 它无须递归就能化解
2. 不断推进
   每次递归调用都必须要使求解状况朝接近基准情形的方向推进
3. 设计法则
   所有的递归调用都能运行
4. 合成效益法则
   在求解一个问题的同一实例时, 切勿在不同的递归调用中做重复性的工作.

** 递归注意事项
1. 递归代码需要警惕堆栈溢出.
2. 递归代码要警惕重复计算
   为了避免重复计算, 可以通过一个数据结构来保存已经求解过的f(k)

** 将递归代码改为非递归代码
递归代码表达能力强, 但空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用等问题.

* 深度优先搜索 - DFS
深度优先搜索的基本模型:
void dfs(int step) {
    判断边界条件
    尝试每一种可能 for (int i=0; i<n; i++) {
        继续下一步 dfs(step+1);
    }
    返回
}

** 深度优先搜索代码示例
[[file:code/numberpermutation.c][1~9之间的全排列]]

* 算法代码
** 排序算法的分析
对排序算法的分析, 可以从以下几个方面入手.
1. 最好、最坏、平均时间复杂度
2. 时间复杂度的系数、常数、低阶
   在实际的软件开发中, 排序的数据可能不多, 在对同一阶时间复杂度的排序算法性能对比的时候,
   就需要考虑.
3. 比较次数和交换(或移动)次数
   基于比较的排序算法的执行过程, 应该把比较次数和交换次数考虑进去
4. 排序算法的内存消耗
   即空间复杂度.
   原地排序: 特指空间复杂度是O(1)的排序算法.
5. 排序算法的稳定性
   如果待排序的序列中存在值相同的元素, 经过排序后, 相等元素之间原有的先后顺序不变. 这就是稳定
   的排序算法.

   稳定排序算法的一个用途:
   给交易系统的"订单"进行排序, 一个是下单时间, 一个是订单金额. 如果此时需要先按订单金额排序,
   金额相同是根据下单时间排序.
   借助稳定排序算法, 实现思路是: 先按订单时间排序, 排序之后的使用稳定的排序算法按照订单金额
   重新排序即可. 两遍排序之后得到的订单数据就符合要求了.

** 有序度与逆序度
有序度是数组中具有有序关系的元素对的个数. 有序元素对用数学表达式如下:
有序元素对: a[i] <= a[j], 如果i<j.
例如: 2, 4, 3, 1, 5, 6这组数据的有序度为11, 其有序元素对为11个, 分别是:
(2, 4), (2, 3), (2, 5), (2, 6)
(4, 5), (4, 6), (3, 5), (3, 6)
(1, 5), (1, 6), (5, 6)

同理对于一个倒序排列的数组, 其有序度是0.
完全有序的数组, 有序度就是n*(n-1)/2

将完全有序的数组的有序度叫做满有序度.
逆序度的定义与有序度相反(默认为从小到大为有序), 逆序元素对: a[i] > a[j], 如果i<j

逆序度 = 满有序度 - 有序度

** 具体的排序算法
冒泡排序包含两个操作原子, 比较和交换, 每交换一次有序度就+1, 不管算法如何改进, 交换次数总是确定的
即为逆序度, 即:n*(n-1)/2 - 初始有序度

插入排序: 将数组中的数据分为两个区间, 已排序区间和未排序区间. 初始已排序区间只有一个元素,即第一个
元素.
插入排序包含比较和移动操作, 对于一个给定的序列, 移动次数就是其逆序度.

选择排序的实现思路类似插入排序, 但选择排序每次会从未排序区间中找到最小的元素, 将其放到已排序区间
的末尾.

插入排序为什么比冒泡排序更受欢迎?
原因如下:
对于一个给定的序列, 冒泡排序不管如何优化, 元素的交换次数是固定的, 插入排序元素的移动次数也是固定
的. 但从代码实现上看, 冒泡排序的数据交换要比插入排序的数据移动复杂, 代码如下:
#+BEGIN_SRC c
// 冒泡排序中的数据交换
if (a[j] > a[j+1]) {
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
}

// 插入排序中数据的移动操纵
if(a[j] > value) {
    a[j+1] = a[j];
} else {
    break;
}
#+END_SRC

插入排序的算法思路有很大的优化空间, 例如: 希尔排序

** 归并排序 - Merge sort
用到了分治思想, 可以借用分治思想来解决非排序的问题. 如如何在O(n)时间复杂度内查找一个无序数组中
的第K大元素.

归并排序的思想如下: 把数组从中间分成前后两部分, 然后对前后两部分分别排序, 再将排好序的
两部分合并在一起, 这样整个数组就都有序了.

分治就是分而治之, 将一个大问题分解成小的子问题来解决.小问题解决了, 大问题也解决了.
分治算法一般都是用递归来实现的, 分治是一种解决问题的处理思想, 递归是一种编程技巧.

** 排序算法代码实现
[[file:code/bubblesort.c][冒泡排序算法]]
[[file:code/insertsort.c][插入排序算法]]
[[file:code/selectsort.c][选择排序算法]]
[[file:code/quicksort.c][快速排序算法]]


** 简单的数据结构
[[file:code/array_queue.c][数组实现的队列 - 顺序队列]]
[[file:code/array_stack.c][数组实现的栈 - 顺序栈]]
[[file:code/single_linklist.c][单链表的实现]]
