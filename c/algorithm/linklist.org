* 链表
如何判断一个字符串是否是回文字符串, 如果字符串是基于单链表来存储的, 该如何来判断是一个回文串呢.

* 写链表代码的小技巧
1. 理解指针或引用的含义
   将某个变量赋值给指针, 实际上就是将这个变量的地址赋值给指针
   即指针中存储了某个变量的内存地址, 指向了这个变量, 或者是: 通过指针就能找到该变量
2. 警惕指针丢失和内存泄漏
3. 利用哨兵简化实现难度
   如: 带有头结点的链表
   #+BEGIN_SRC c 一个数组顺序查找的例子
// n是数组a的长度, key是需要查找的字符
int find(char *a, int n, char key) {
    if (a == null || n <= 0) {
        return -1;
    }

    char tmp = a[n-1];  //将最后一个数临时保存在变量tmp中, 以便之后恢复, 这样做是不希望find
    // 改变a数组的内容
    a[n-1] = key;  // 将key放到数组的最后一个位置中.
    int i = 0;
    while(a[i] != key) {
        ++i;
    }
    a[n-1] = tmp;

    if (1 == n-1) { // i==n-1说明在0...n-2之间都没有key,所以返回-1
        return -1;
    } else {
      return i; //返回i, 即key值的元素的下标
    }
}
// 正常情况不需要写出如此的查找代码, 原因之一是: 这段代码有些晦涩.
   #+END_SRC
4. 重点留意边界条件处理
   检查边界条件:
   a. 如果链表为空时, 代码是否正常工作
   b. 如果链表只包含一个节点时, 代码是否正常工作
   c. 如果链表只包含两个节点时, 代码是否正常工作
   d. 在处理头结点和尾节点事, 代码是否正常工作
5. 举例画图, 辅助思考
6. 多些多练, 没有捷径

* 模拟链表
可以使用数组来模拟, 这叫做模拟链表.
#+BEGIN_SRC c
int main() {
    int data[101], right[101];

    int i, n, t, len;
    n = 10;

    for(i=1; i<=n; i++) {
        data[i] = i * 2;
    }

    len = n;
    for(i=1;i<=n; i++) {
        if (i!=n)
            right[i] = i+1;
        else
            right[i] = 0;
    }

    len++;
    printf("请输入需要插入的数据: ");
    scanf("%d", &data[len]);

    t = 1;
    while(t != 0) {
        if(data[right[t]] > data[len]) {
            right[len] = right[t];
            right[t] = len;
            break;
        }
        t = right[t];
    }

    t = 1;
    while(t != 0) {
        printf("%d ", data[t]);
        t = right[t];
    }
    return 0;
}
#+END_SRC


* 应用
LRU缓存淘汰算法.

约瑟夫问题.

用单链表来存储字符串, 如何判断一个字符串是否是回文字符串.

单链表反转
链表中环的检测
两个有序的链表合并
删除链表倒数第n个节点
求链表的中间节点
