* 本书源码使用
https://resources.oreilly.com/examples/9781565924536.git # 源码地址
使用git下载之后, 进入源码目录examples_unix中, 将该目录的路径加入到环境变量ALGOWC_TOPDIR中
之后执行make -f xx.mak即可编译源文件

make -f xx.mak clean  # 清除编译的中间结果

* 算法设计的一般方法
** 随机法
依赖于随机数的统计特性, 如快速排序. 快速排序中选择的哨兵就是随机的.

** 分治法
包含3个步骤: 分解、求解与合并.
分解阶段将数据分解为更小、更容易管理的部分. 每个子问题都是独立的.
求解阶段对每个分解出的部分进行处理.
合并阶段将每部分处理的结果进行合并.

** 动态规划
将较大问题分解为子问题最后在将结果合并, 处理问题的方式与子问题之间的关系有关.
动态规划中子问题之间可能有关联.

** 贪心算法
在求解问题时总能够做出在当前的最佳选择. 不是从整体最优上考虑, 而仅仅是在某种意义上的
局部最优解. 因此贪心算法并不会一直产生最优结果, 在某些方面贪心算法确是最佳选择.

一个采用贪心算法的例子是: 霍夫曼编码.

** 近似法
该方法并不计算出最优解, 只计算出"足够好"的解.

* 第2章 - 指针
** 基础
搞清楚一个指针需要搞清楚指针的四方面的内容: 指针的类型, 指针所指向的类型, 指针的值(指针所指向
的内存区), 还有指针本身所占据的内存区.

函数指针: 指针指向可执行代码段或指向调用可执行代码段的信息块,而不是指向某种具体数据.
它们把函数当做一小段数据来存储和管理.

指向无效地址的指针有时被称为悬空指针.

当声明一个指针时, 仅仅只是为指针本身分配了空间, 并没有为指针所指向的数据分配空间.
为数据分配存储空间有两种方法: 一种是直接声明一个变量;
另一种是在运行时动态地分配存储空间(例如: 使用malloc或realloc).

C语言中, 多维数组其实是以行主序的方式存储的; 这也就说明多维数组右边下标变化速度要比
由左边下标变化来得更快.


void* 用于表示泛型指针.
当转换指针时, 需要注意内存中的数据对齐方式. 指针的类型转换会破坏计算机本身的对齐方式.

函数指针将函数当做普通数据那样存储和管理, 函数指针有一种固定的形式, 就是包含一个确定的返回
值类型和若干个函数参数.

* 第三章 - 递归调用
** 递归
递归过程中的两个基本阶段: 递推与回归.
在递推阶段, 每个递归调用通过进一步调用自己来记住这次递归过程. 当其中有调用满足终止条件时,
递推结束.

一旦递推阶段结束, 处理过程就进入回归阶段, 在这之前的函数调用以逆序的方式回归, 直到最初调用的
函数返回为止, 此时递归过程结束.

在正式的的分析中, 递归通常用来描述算法的运行时间.

** 尾递归
递归的一种形式, 编译器会为此产生优化的代码.
如果一个函数中所有递归形式的调用都出现在函数的末尾, 则叫做尾递归.

当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时, 就是尾递归.

尾递归函数的特定是在回归过程中不用做任何操作.

当编译器检测到一个函数是尾递归的时候, 就覆盖当前的活跃记录而不是在栈中去创建一个新的.
因为递归调用是当前活跃期内最后一条待执行的语句, 于是当这个调用返回时栈帧中并没有其他事情可做,
因此也就没有保存栈帧的必要了, 通过覆盖当前的栈帧而不是在其之上重新添加新一个, 这样所使用的栈空间
就大大缩减了.

尾递归的例子:
#+BEGIN_SRC c  使用尾递归实现阶乘
int fact(int n, int a) {
    if(n <= 1) {
        return a;
    } else {
        return fact(n-1, n*a);
    }
}

int main() {
    int num = fact(6, 1);
    printf("%d\n", num);
    return 0;
}
#+END_SRC

使用尾递归形式实现斐波那契数列的计算:
#+BEGIN_SRC c
int fib(int n, int a, int b) {
    if(n <= 1)
        return b;
    else
        return fib(n-1, b, a+b)
}
#+END_SRC

在写递归函数时, 应当尽量将递归函数写成尾递归的形式. 将递归函数转换为尾递归形式的时候, 可以参考
上面的两个例子.

* 算法分析
** 算法性能评估
通常将最坏情况当做很多算法性能的度量, 但也有例外. 快速排序算法就使用了平均情况下的度量. 原因是:
它使用了概率论的基础, 从而有效的保证了平均情况下性能的准确性.

* 集合
** 概念
集合是不同对象(称为成员)的无序聚集.

韦恩图: 一种帮助我们可视化地确定集合操作结果的图形表示法
位矢量表示: 一种表示集合的方法. 当已知全集合很小时很有用.
全集合中的每个成员都表示为数组中的一位, 如果某个成员属于集合,它相应的位置1;否则相应的位置0

* 哈希表
** 术语
线性同余发生器

** 链式哈希表
将数据存储在"桶"中的哈希表, 每个"桶"都是一个链表, 且链表的容量能够随着冲突的增加而增大

** 开地址哈希表
将数据存储在表本身中, 通过各种探查方法来避免冲突问题.

冲突解决办法: 探查这个表, 直到找到一个可以放置元素的槽. 例如: 如果要插入一个元素, 我们探查槽位
直到定位到该元素或直到找到一个空槽位. 如果在找到元素之前找到一个空槽或遍历完所有槽位, 则说明此
元素在表中不存在.

在进行操作时, 要尽可能地减少探查的次数, 探查次数取决于两件事: 哈希表的负载因子和元素均匀分布的
程度.

假设进行均匀散列, 我们能够在一个开地址哈希表中探查的槽位个数是: 1/(1-α), 例如: 在负载系数为
α=0.5, 我们希望能够探查的槽位个数为1/(1-0.5)=2. 因此, 系数越大, 探查的次数越多.
在一个对时间特别敏感的应用用, 就可以通过增加哈希表的空间来提高探查的效率(注意: 前提是hash函数
是均匀散列的).

一般来说: 开地址哈希表中探查槽位的哈希函数定义为: h(k, i) = x; k是键, i是到目前为止探查的次数.
x是得到的哈希编码. 通常情况下, h会调用一个或多个具有相同属性的辅助哈希函数, 在开地址哈希表中
h必须具有一个额外的属性, 当i从0增加到m-1时(m为hash表中槽位个数), 在第二次访问任何槽位之前, 表
中所有的槽位都必须访问过一遍, 否则就说明不需要探查所有的槽位就能找到结果.

线性探查: 探查表中连续的槽位, 正式表述为: 如果0<i<(m-1)(m是槽位个数), 则一个线性探查方法的哈希
函数定义为: h(k, i) = (h'(k) + i) mod m, h'是一个辅助哈希函数.
线性探查的优点是简单, 而且对m没有限制, 但并不能近似均匀散列. 特别是当遇到一种称为基本聚集的情况
时, 基本聚集会产生很长的探查序列, 从而使表变得越来越大.

双散列: 就是计算两个辅助哈希函数哈希编码的和来得到哈希编码. 正式表述为:
h(k, i) = (h1(k) + ih2(k)) mod m
为了保证第二次访问任何一个槽之前其他所有槽都访问过了, 必须遵循如下规则: 一种方法是, m必须是
2次幂, 让h2返回一个奇数值; 另一种方法是选择m为一个素数, h2返回的值在1<=h2(k)<=m-1

** 哈希负载因子
α = n/m
n表中元素的个数
m是"桶"的个数.

使用取余法作为hash函数: 通常会选择的数是一个素数, 且不能太接近与2的幂, 同时还要考虑存储空间的
限制和负载因子.

使用乘法作为hash函数: 将整型键k乘以一个常数A(0<A<1), 取结果的小数部分, 然后乘以m取结果的整数
部分, 通常情况下, A取0.618 = (根号5 - 1) / 2

* 树
