* 本书源码使用
https://resources.oreilly.com/examples/9781565924536.git # 源码地址
使用git下载之后, 进入源码目录examples_unix中, 将该目录的路径加入到环境变量ALGOWC_TOPDIR中
之后执行make -f xx.mak即可编译源文件

make -f xx.mak clean  # 清除编译的中间结果

* 算法设计的一般方法
** 随机法
依赖于随机数的统计特性, 如快速排序. 快速排序中选择的哨兵就是随机的.

** 分治法
包含3个步骤: 分解、求解与合并.
分解阶段将数据分解为更小、更容易管理的部分. 每个子问题都是独立的.
求解阶段对每个分解出的部分进行处理.
合并阶段将每部分处理的结果进行合并.

** 动态规划
将较大问题分解为子问题最后在将结果合并, 处理问题的方式与子问题之间的关系有关.
动态规划中子问题之间可能有关联.

** 贪心算法
在求解问题时总能够做出在当前的最佳选择. 不是从整体最优上考虑, 而仅仅是在某种意义上的
局部最优解. 因此贪心算法并不会一直产生最优结果, 在某些方面贪心算法确是最佳选择.

一个采用贪心算法的例子是: 霍夫曼编码.

** 近似法
该方法并不计算出最优解, 只计算出"足够好"的解.

* 第2章 - 指针
** 基础
搞清楚一个指针需要搞清楚指针的四方面的内容: 指针的类型, 指针所指向的类型, 指针的值(指针所指向
的内存区), 还有指针本身所占据的内存区.

函数指针: 指针指向可执行代码段或指向调用可执行代码段的信息块,而不是指向某种具体数据.
它们把函数当做一小段数据来存储和管理.

指向无效地址的指针有时被称为悬空指针.

当声明一个指针时, 仅仅只是为指针本身分配了空间, 并没有为指针所指向的数据分配空间.
为数据分配存储空间有两种方法: 一种是直接声明一个变量;
另一种是在运行时动态地分配存储空间(例如: 使用malloc或realloc).

C语言中, 多维数组其实是以行主序的方式存储的; 这也就说明多维数组右边下标变化速度要比
由左边下标变化来得更快.


void* 用于表示泛型指针.
当转换指针时, 需要注意内存中的数据对齐方式. 指针的类型转换会破坏计算机本身的对齐方式.

函数指针将函数当做普通数据那样存储和管理, 函数指针有一种固定的形式, 就是包含一个确定的返回
值类型和若干个函数参数.

* 第三章 - 递归调用
** 递归
递归过程中的两个基本阶段: 递推与回归.
在递推阶段, 每个递归调用通过进一步调用自己来记住这次递归过程. 当其中有调用满足终止条件时,
递推结束.

一旦递推阶段结束, 处理过程就进入回归阶段, 在这之前的函数调用以逆序的方式回归, 直到最初调用的
函数返回为止, 此时递归过程结束.

在正式的的分析中, 递归通常用来描述算法的运行时间.

** 尾递归
递归的一种形式, 编译器会为此产生优化的代码.
如果一个函数中所有递归形式的调用都出现在函数的末尾, 则叫做尾递归.

当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时, 就是尾递归.

尾递归函数的特定是在回归过程中不用做任何操作.

当编译器检测到一个函数是尾递归的时候, 就覆盖当前的活跃记录而不是在栈中去创建一个新的.
因为递归调用是当前活跃期内最后一条待执行的语句, 于是当这个调用返回时栈帧中并没有其他事情可做,
因此也就没有保存栈帧的必要了, 通过覆盖当前的栈帧而不是在其之上重新添加新一个, 这样所使用的栈空间
就大大缩减了.

尾递归的例子:
#+BEGIN_SRC c  使用尾递归实现阶乘
int fact(int n, int a) {
    if(n <= 1) {
        return a;
    } else {
        return fact(n-1, n*a);
    }
}

int main() {
    int num = fact(6, 1);
    printf("%d\n", num);
    return 0;
}
#+END_SRC

使用尾递归形式实现斐波那契数列的计算:
#+BEGIN_SRC c
int fib(int n, int a, int b) {
    if(n <= 1)
        return b;
    else
        return fib(n-1, b, a+b)
}
#+END_SRC

在写递归函数时, 应当尽量将递归函数写成尾递归的形式. 将递归函数转换为尾递归形式的时候, 可以参考
上面的两个例子.

* 算法分析
** 算法性能评估
通常将最坏情况当做很多算法性能的度量, 但也有例外. 快速排序算法就使用了平均情况下的度量. 原因是:
它使用了概率论的基础, 从而有效的保证了平均情况下性能的准确性.

* 链表
