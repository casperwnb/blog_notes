* Mysql中的UTF8
MySQL 的utf8mb4是真正的UTF-8实现.
MySQL 的utf8是一种"专属的编码", 它能够编码的 Unicode 字符并不多.

因此所有在使用"utf8"的mysql和Mariadb用户都应该改用"utf8mb4", 永远不要使用utf8.

[[https://mathiasbynens.be/notes/mysql-utf8mb4][将mysql中的utf8转为utf8mb4]]

* Mysql存储表情符号
1. 数据库的字符编码需要设置为utf8mb4
2. 连接数据库时, charset需要设置为utf8mb4

* Mysql 常用语句
mysql -h <addr> -P <port> -u <user> -p <pwd>

show processlist  # 显示哪些线程正在运行
show variables  # 显示系统变量信息

select database()  # 查看当前数据库
selec now(), user(), version()  # 显示当前时间, 用户名, 数据库版本

* mysql root密码重置
1. 停止mysql服务
2. Linux: /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &
   windows: mysqld --skip-grant-tables
3. use mysql
4. update `user` set password=password("<pwd>") where `user`="root"
5. flush privileges;

* mysql用户和权限管理
用户信息表: mysql.user

# 增加用户
create user <user> identified by [password] <pwd>
执行该语句:必须拥有mysql数据库的全局create user权限, 或拥有insert权限. 只能创建用户, 不能赋予权限.
用户名形如: 'user_name'@'ip', 密码也需要引号.
要在纯文本中指定密码, 需忽略password关键字, 要把密码指定为由password()函数返回的混变值, 需要包含
password关键字

# 为当前用户设置密码
set password = password('pwd')
# 为指定用户设置密码
set password for <username> = password('pwd')

# 分配权限
grant <权限列表> on 表名 to <username> [identified by [password] 'pwd']
all privileges  表示所有权限
*.*  表示所有库的所有表
库名.表名  表示某库下面的某表


# 查看权限
show grants for <user>
show grants
show grants for current_user
show grants for current_user()

# 撤销权限
revoke <权限列表> on 表名 from 用户名
* brew 安装的mysql的配置文件设置
my.cnf文件在: /usr/local/etc/my.cnf

* mysql的数据类型
** 示例数据
http://dev.mysql.com/doc/index-other.html: employee数据库, dbt3数据库: 是通过database test
suit程序生成的.

tpcc数据库: https://code.google.com/archive/p/david-mysql-tools/downloads

** unsigned
在mysql中使用unsigned可能会带来一些负面影响, 如:
#+BEGIN_SRC sql
create table t(a int unsigned, b int unsigned);
insert into t select 1, 2;
select a-b from t;  -- 执行这一句会报错,
-- BIGINT UNSIGNED value is out of range in '`blog`.`t`.`a` - `blog`.`t`.`b`'
-- 如果想获取-1这个值, 可以执行set sql_mode='no_unsigned_subtraction'
#+END_SRC

如果想理解上面的问题, 可以执行如下的c代码:
#+BEGIN_SRC c
#include <stdio.h>

int main() {
    unsigned int a;
    unsigned int b;

    a = 1;
    b = 2;
    printf("a-b=%d, 0x%x\n", a-b, a-b);
    printf("a-b=%u, 0x%x\n", a-b, a-b);
    return 0;
}
#+END_SRC

因此在设计数据库时, 对于INT无法存放的数据, UNSIGNED INT也可能无法存放, 此时还不如在数据库设计
阶段将INT类型提升为BIGINT类型.

** zerofill
如果宽度小于设定的宽度, 则自动填充为0.

如果没有zerofill属性, 括号内的数字是毫无意义的.

#+BEGIN_SRC sql
show create table t;

alter table t change column a a int(4) unsigned zerofill;
select a, b from t;
#+END_SRC
mysql实际存储的还是1.

** sql_mode设置
sql_mode的设置是一种比较冒险的设置, 该设置下可以允许一些非法操作. 如可以将NULL插入NOT NULL的
字段, 也可以插入一些非法日期, 如"2012-12-32". 生产环境中强烈建议将该值设置为严格模式.

正确的设置sql_mode还可以做一些约束检查的工作. 可以在my.cnf文件或者客户端工具中进行.

#+BEGIN_SRC sql
select @@global.sql_mode\G; -- 查看全局sql_mode的设置情况
select @@session.sql_mode\G;  -- 查看当前连接的设置

set global sql_mode="strict_trans_tables"  -- 将当前的sql_moe设置为严格模式
#+END_SRC

严格模式是指将sql_mode变量设置为strict_trans_tables或strict_all_tables中的至少一种.
| 可选择的模式               | 效果                                                  |
|----------------------------+-------------------------------------------------------|
| strict_trans_table         | 如果一个值不能插入到一个事务表中, 则中断当前的操作    |
|                            | 不影响非事务表                                        |
|----------------------------+-------------------------------------------------------|
| allow_invalid_dates        | 并不完全对日期的合法性进行检查, 只检查月份是否在1~12  |
|                            | 日期是否在1~31                                        |
|                            | 仅对date和datetime有效, timestamp无效                 |
|----------------------------+-------------------------------------------------------|
| ansi_quotes                | 启用后不用双引号来引用字符串, 因为它将被解释为识别符  |
|----------------------------+-------------------------------------------------------|
| error_for_division_by_zero | 在insert/update中, 如果数据被零清除, 则产生错误       |
|                            | 如果未给出该模式, 则会返回NULL.                       |
|                            | 如果用到insert/update ignore, 产生警告, 但结果为NULL  |
|----------------------------+-------------------------------------------------------|
| high_not_precedence_not    | 更改操作符的优先顺序, 如: not a between b and c       |
|                            | 被解释为not(a between b and c), 但在一些旧版本中      |
|                            | 会被解释为(not a) between b and c                     |
|                            | mysql中的between a and b被解释为[a, b]                |
|----------------------------+-------------------------------------------------------|
| ignore_space               | 函数名和括号"("之间有空格,                            |
| no_auto_create_user        | 禁止grant创建密码为空的用户                           |
| no_auto_value_on_zero      | 影响自增长列, 默认设置下, 插入0或NULL代表生成下一个   |
|                            | 自增长值, 如果用户希望插入的值为0, 而该列又是自增长的 |
|                            | 就使用该选项                                          |
|----------------------------+-------------------------------------------------------|
| no_backslash_escape        | "\"作为普通字符而非转义字符                           |
| no_dir_in_create           | 创建表时忽略所有的index directory和data directory     |
| no_engine_substitution     | 如果需要的存储引擎被禁用或未编译, 则抛出错误.         |
|                            | 默认用默认的存储引擎代替, 并抛出一个异常              |
| no_unsigned_subtraction    | 启用后, unsigned类型相减返回signed类型                |
| no_zero_date               | 非严格模式下, 可以插入0000-00-0000:00:00的非法日期    |
|                            | 启用后, 不允许插入零日期                              |
| no_zero_in_date            | 严格模式下, 不允许日期和月份为0                       |
| only_full_group_by         | 对于group by聚合操作, 如果在select中的列没有在        |
|                            | group by中出现, 那么该sql是不合法的                   |
| pad_char_to_full_length    | char类型字段, 不要截断空洞数据.空洞数据值为0x20的数据 |
| pipes_as_concat            | 将两个管道符视为字符串的连接符                        |
| real_as_float              | 将real视为float的同义词                               |
| strict_all_tables          | 对所有表启用严格模式, 启用后如果是非事务引擎, 这时    |
|                            | 数据可能停留在一个未知的状态, 因此需要小心该选项      |
|                            | 可能带来的潜在影响                                    |

** 日期和时间类型
datetime: 8字节
date: 3字节
timestamp: 4字节
yaer: 1字节
time: 3字节

mysql5.5版本之前(包括5.5), 日期类型不能精确到微妙级别, 任何的微秒值都会被数据库截断.
microsecond来提取日期中的微秒值. mysql的cast函数在强制转换到datetime时会保留到微秒数, 但插入
后任然会被截断.

mysql 5.6.4+ 增加了对秒的小数部分的支持, 语法为type_name(fsp), type_name的类型可以是TIME,
datetime, timestamp. fsp表示支持秒的小数部分的精度, 最大为6, 表示微秒.


timestamp与datetime的区别:
1. 在建表时, timestamp可以设置一个默认值, datetime不可以
2. 更新表时, timestamp可以设置自动更新时间为当前时间

time显示的范围是: -838:59:59~838:59:59, time类型不仅可以用来保存一天中的时间, 也可以用来保存
时间间隔.

** 时间函数
current_timestamp与now是同义词, sysdate返回的是执行当当前函数时的时间.
now()返回的值不能直接加上或减去一个数字, 需要使用特定的date_add/date_sub函数.
select now() as now, date_add(now(), interval 1 day) as tomorrow;
date_add会自动处理闰月的问题.

select * from t where date_format(now(), "%Y%m%d")='xxx';  该查询语句是不会使用索引的.

* SQL查询语句的执行
[[file:~/Learn_space/blog_notes/database/img/mysql_logicalframe.png][mysql逻辑架构图]]
** 分层
mysql分为server层和存储引擎层.
server层包括: 连接器、查询缓存、分析器、优化器、执行器等. 涵盖了mysql的大多数核心服务功能
以及所有的内置函数(如日期、时间、数学和加密函数等), 所有夸存储引擎的功能也都在这一层实现.
如存储过程、触发器、视图等.

存储引擎负责数据的存储和提取. 其架构模式是插件式的, 支持InnoDB等多个引擎.
从mysql5.5.5+ innodb是默认的存储引擎.

** 1. 连接器
负责跟客户端建立连接、获取权限、维持和管理连接. 通过认证后, 连接器会到权限表里查询权限,
之后该连接里的权限判断逻辑都将依赖于此时读取到的权限.

一个用户成功建立连接后, 即使使用管理员账号对该用户的权限做了修改, 也不会影响已经存在连接的
权限, 修改完成后, 之后重新建立的连接才会使用新的权限设置.

客户端连接后, 如果太长时间内都没有动静, 连接器会自动断开, 该时间参数由wait_timeout控制.

数据库中的长连接是指: 连接成功后, 如果客户端持续有请求, 则一直使用同一个连接, 短连接则是
指每次执行完很少的几次查询就断开连接, 下次查询再重新建立一个.

有些时候mysql占用的内存涨的特别快, 是因为mysql在执行过程中临时使用的内存是管理在连接对象里的
这些资源在连接断开时才会释放, 如果长连接累计下来, 可能导致内存占用太大, 被系统强行杀掉.
从现象看就是mysql异常重启了.

解决方法:
1. 定期断开长连接, 使用一段时间后, 或程序里判断执行过一个占用内存的大查询后, 断开连接
2. 如果使用的是mysql5.7+, 可以在每次执行一个比较大的操作后, 通过执行mysql_reset_connection
   来重新初始化连接资源. 该过程不需要重连和重新做权限验证.

** 2. 查询缓存
mysql拿到一个查询请求后, 会先查缓存.
大多数情况下, 不建议使用查询缓存, 因为查询缓存往往弊大于利.

查询缓存失效非常频繁, 只要有对一个表的更新, 这个表上所有的查询缓存都会被清空.
将query_cahce_type设置为DEMAND, 这样对于默认的sql语句都不使用查询缓存, 而对于确定要使用
查询缓存的语句可以使用SQL_CACHE显式指定, 如:
select SQL_CACHE * from T where ID=10;

mysql8.0+中将查询缓存的整块功能都删掉了.

** 3. 分析器
如果没有命中查询缓存, 就要开始真正的执行语句了.
会先做"词法分析", 然后"语法分析". 根据词法分析的结果, 语法分析器会根据语法规则判断sql语句是否
满足mysql的语法. 一般语法错误会提示第一个出现错误的位置.

** 4. 优化器
开始执行前, 需要经过优化器的处理.
当表里有多个索引的时候, 决定使用哪个索引. 或者在一个语句有多表关联的时候, 决定各个表的连接顺序.

优化器阶段完成后, 该语句的执行方案就确定了. 然后进入执行器阶段.

** 5. 执行器
开始执行语句, 先判断对该表是否有查询的权限, 如果没有, 就会返回没有权限的错误提示. 有权限会打开
表继续执行, 执行器就根据表的引擎定义, 去使用这个引擎提供的接口.

可以在数据库的慢查日志中看到一个rows_examined字段, 表示该语句执行过程中扫描了多少行. 该值就是
在执行器每次调用引擎获取数据行的时候累加的.

有些场景下, 执行器调用一次在引擎内部则扫描了多行, 因此引擎扫描行数跟rows_examined并不完全相同.

* SQL更新语句的执行
更新语句也会执行查询流程的那一套流程. 更新流程还涉及到两个重要的日志模块: redo log(重做日志),
binlog(归档日志)

** redo log
Mysql使用了WAL技术(Write-Ahead logging), 即先写日志再写磁盘. 当有一条记录需要更新的时候, Innodb
引擎就会先把记录写到redo log里, 并更新内存此时更新就完成了. 同时Innodb引擎会在适当的时候将这个
操作记录到磁盘里面, 而这个更新往往是在系统比较空闲的时候做.

innodb的redo log是固定大小的, 可以配置为一组4个文件, 每个文件的大小是1G. 从头开始写, 写到末尾就
又回到开头循环写. write pos是当前记录的位置, checkpoint是当前要擦除的位置, 擦除前要把记录更新到
数据文件中.

有了redo log, Innodb就可以保证即使数据库异常重启, 之前提交的记录也不会丢失,
这个能力称为crash-safe.

redo-log是innodb引擎特有的日志.

** binlog - 日志模块
binlog(归档日志), 这是server层自己的日志.

不同点:
1. redo log是innodb特有的, binlog是mysql的server层实现的, 所有的引擎都可以使用
2. redo log是物理日志, 记录的是"在某个数据页上做了什么修改", binlog是逻辑日志, 记录的是这个语句
   的原始逻辑, 如"给Id=2这一行的c字段+1"
3. redo log是循环写的, binlog是可以追加写入的.
4. binlog有两种模式, statement格式是记录sql语句, row格式会记录行内容, 记两条, 更新前和更新后

** update执行时的流程
1. 执行器先找引擎取ID=2这一行, ID是主键, 引擎直接用树搜索找到这一行, 如果ID=2这一行所在的数据页
   本来就在内存中, 就直接返回给执行器. 否则需要先从磁盘读入内存, 然后再返回
2. 执行器拿到引擎给的行数据, 把该值+1, 得到新的一行数据, 再调用引擎接口写入这行新数据
3. 引擎将这行数据更新到内存中, 同时将这个更新操作记录到redo log中, 此时redo log处于prepare
   状态, 然后告知执行器执行完成了, 随时可以提交事务
4. 执行器生成该操作的binlog, 并把binlog写入磁盘.
5. 执行器调用引擎的提交事务接口, 引擎把刚刚写入的redo log改成提交状态, 更新完成

** 两阶段提交
两阶段的提交是为了让两份日志之间的逻辑一致.

数据恢复: DBA会做数据备份, 包括binlog, 同时系统会定期做整库备份. 如果某天发现有误操作, 则恢复过程
如下:
1. 首先找到最近的一次全量备份, 将该备份恢复到临时库
2. 从备份的时间点开始, 将备份的binlog依次取出来, 重放到中午误删除表之前的那个时刻
3. 此时临时库中的数据就跟误删除之前的数据一致了, 然后将表数据从临时库取出来, 按需恢复到线上库

由于redo log和binlog是两个独立的逻辑, 如果不用两阶段提交, 就可能发生如下的问题.
以update语句为例.
假设当前ID=2的行, 字段c的值为0, 再假设在执行update语句的过程中在写第一个日志后, 第二个日志还没有
写完期间发生了crash, 会出现什么请情况呢?
1. 先写redo log后写binlog. 假设在redo log写完, binlog还没写完时, mysql进程异常重启. redo log写完
   后, 系统崩溃任然能够将数据找回, 此时该行的值为1.
   但由于binlog没有写完, 此时binlog里没有记录这个语句, 因此之后备份日志的时候存起来的binlog就没有
   这条日志, 此时如果使用这个binlog来恢复临时库的话, 恢复出来的c值就是0, 与源库不同.
2. 先写binlog后写redo, 分析原理类似.

数据库扩容的时候也需要用到binlog.

innodb_flush_log_at_trx_commit 该参数设置成1的时候, 表示每次事务的redo log都直接持久化到磁盘.
建议设置为1, 这样可以保证mysql异常重启后数据不丢失.

sync_binlog 设置为1的时候, 表示每次事务的binlog都持久化到磁盘, 可以保证mysql异常重启之后binlog
不会丢失.
