* 容器
** 介绍
容器其实是一种沙盒技术. 沙盒就是能够像一个集装箱一样将应用装起来的技术, 这样应用于应用之间就有了
边界而不至于互相干扰, 而被装进集装箱的应用, 也可以被方便的搬来搬去, 这就是PaaS最理想的状态.

容器技术的核心功能就是通过约束和修改进程的动态表现, 从而为其创造出一个"边界", 因此容器是一种
特殊的进程.

在容器内, 除了pid=1的进程, 其他进程不受docker控制. 其他进程是指通过exec进去之后启动的后台进程不
受控制, 此处的控制是指它们的回收和生命周期管理.

"敏捷"和"高性能"是容器相较于虚拟机最大的优势.

一个道理: 容器本身没有价值, 有价值的是"容器编排"

** 一些问题
1. 容器是一个单进程, 在一个镜像中集成了jdk, netstat,ping等命令, 该容器启动时是一个java进程,
   但通过docker exec 进入该容器后可以执行ping等命令, 那么这些ping命令在容器的运行过程中是在
   运行的吗?
   答: 这些命令是在运行的, 但不受docker控制, 就像野孩子. 容器的单进程的意思不是只能运行一个进程,
   而是只有一个进程是可控的. 此处的控制指的是它们的回收和生命周期管理.
2. docker容器里跑的进程都是entrypoint进程的子进程. docker基本上是旁路控制的作用.

* 容器基础
[[file:content/docker_base.org][容器基础知识]]

* 使用docker部署一个python测试程序
#+BEGIN_SRC python app.py
from flask import Flask

import socket
import os

app = Flask(__name__)

@app.route("/")
def hello():
    html = "<h3>Hello {name}!</h3>" \
           "<b>Hostname:</b> {hostname} <br/>"
    return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname())


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
#+END_SRC
#+BEGIN_SRC text requirements.txt
Flask
#+END_SRC
#+BEGIN_SRC text Dockerfile
from python:2.7-slim
workdir /app
add . /app
run pip install --trusted-host pypi.python.org -r requirements.txt
expose 80
env NAME casper
cmd ["python", "app.py"]
#+END_SRC

docker build -t flask:v1 .  # 构建镜像
docker run -d -p <hostport>:80 flask:v1  # 运行一个容器
docker inspect -f '{{.State.Pid}}'  <containerid>  # 查看容器在宿主机上的进程ID

#+BEGIN_SRC c exec.c  进入某个namespace的c代码
#define _GUN_SOURCE
#include <fcntl.h>
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#define errExit(msg) do {\
    perror(msg);\
    exit(EXIT_FAILURE);\
} while(0)

int main(int argc, char*argv[]) {
    int fd;

    fd = open(argv[1], O_RDONLY);
    if (setns(fd, 0) == -1) {
        errExit("setns");
    }

    execvp(argv[2], &argv[2]);
    errExit("execvp");
}

// 这段代码一共接收两个参数, 第一个参数是当前进程要加入的Namespace文件路径,
// 比如/proc/<PID>ns/net, 第二个参数是需要在该namespace里运行的进程
// 核心操作是: 通过open调用打开了指定的Namespace文件, 将该文件的描述符fd
// 交给setns使用, 在setns执行后, 当前进程就加入了这个文件对应的namespace中了.
#+END_SRC
gcc exec.c -o ESpace

./ESpace /proc/<pid>/ns/net /bin/bash  # 进入指定pid的net namespace中运行/bin/bash命令

docker commit <containerid> xxx:tag  # 将运行的容器提交为一个新的镜像

* 构造容器
[[file:content/buildmydocker.org][构造容器]]

* kubernetes
[[file:content/kubernetes.org][kubernetes笔记]]

[[https://github.com/gjmzj/kubeasz][kubeasz-k8s部署使用的ansible脚本]]

kubespray, kubeadm, kubeasz, kops

