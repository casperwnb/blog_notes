* 反射
** 反射
在运行时更新变量和检查他们的值、调用它们的方法和他们支持的内在操作, 但在编译时并不知道这些变量的
具体类型.

反射是一个复杂的内省技术, 不应该随意使用.
最熟悉的例子就是fmt.Fprintf函数提供的字符串格式化处理逻辑, 可以对任意类型的值格式化并打印,
并且支持用户自定义的类型.

#+BEGIN_SRC go 一个简单的例子
func MySprintf(x interface{}) string {
    type stringer interface{
        String() string
    }

    switch x := x.(type) {
        case stringer:
            return x.String()
        case string:
            return x
        // ... 无穷无尽, 并且还无法支持用户自定义的数据, 此时就需要用到反射
    }
}
#+END_SRC

** reflect.Type和reflect.Value
一个Type表示一个Go类型, 是一个接口, 有许多方法来区分类型和检查它们的组件.
reflect.TypeOf接受任意的interface{}类型, 并返回对应动态类型的接口值.
%T使用reflect.TypeOf的结果输出

#+BEGIN_SRC go
t := reflect.Typeof(3)
fmt.Println(t.String())  // int
fmt.Println(t)  // int
#+END_SRC

reflect.Type接口是满足fmt.Stringer接口的.

reflect.Value可以持有一个任意类型的值, reflect.ValueOf接受任意的interface{}类型, 并返回对应动态
类型的reflect.Value, reflect.Value也可以持有一个接口值.
%v使用reflect.Value的结果输出.
* GO 语言类型推断带来的好处
Go语言的类型推断只应用在了对变量或常量的初始化方面

1. 重构时的好处
   #+BEGIN_SRC go
func main() {
    var name = getTheFlag()
    flag.Parse()
    fmt.Println(*name)
}

func getTheFlag() *string {
    return flag.String("name", "everyone", "username")
}
   #+END_SRC
   此处用getTheFlag函数包裹了对flag.String的调用, 并将其结果直接作为getTheFlag函数的结果, 结果的
   类型是*string. 如果此时想重构代码, 只需直接修改getTheFlag函数的实现即可, 不用修改调用该函数的
   地方.  即name的类型可以在其初始化时由其他程序动态动态的确定.

   重构: 不改变某个程序与外界的任何交互方式和规则, 而只改变其内部实现的代码修改方式

   总结: Go语言的类型推断可以明显提升程序的灵活性, 使得代码重构变得更加容易, 同时又不会给代码的
   维护带来额外负担(即可以避免散弹式的代码修改), 更不会损失程序的运行效率.

* sync.Mutex 与 sync.RWMutex
** 基础
sync是"同步"的意思, 一旦数据被多个线程共享, 则可能会产生争用和冲突的情况.
这种情况也被称为竞态条件(race condition), 这往往会破坏共享数据的一致性.

共享数据的一致性代表某种约定, 即多个线程对共享数据的操作总是可以达到它们各自预期的效果. 如果一致
性得不到保证, 将会影响一些线程中代码和流程的正确执行, 甚至会造成某种不可预知的错误. 这种错误一般
很难发现和定位, 排查起来的成本会非常的高.

同步的两个用途: 一个是避免多个线程在同一时刻操作同一个数据块, 另一个是协调多个线程, 以避免它们在
同一时刻执行同一个代码块.

可以将它们看做是共享资源或者说共享资源的代表, 同步其实就是在控制多个线程对共享资源的访问.

一个线程在想要访问某一个共享资源的时候, 需要先申请对该资源的访问权限, 并且只有在申请成功之后, 访问
才能真正开始. 当线程对共享资源的访问结束时, 它还必须归还对该资源的访问权限, 若要再次访问仍需申请.

只要一个代码片段需要实现对共享资源的串行化访问, 就可以被视为一个临界区(critical section).

如果针对同一个共享资源, 这样的代码片段有多个, 那么它们就可以被称为相关临界区.

最重要且常用的同步工具当属互斥量(mutual exclusion, 简称mutex). sync包中的Mutex就是与其对应的类型,
该类型的值可以被称为互斥量或者互斥锁.

** 使用互斥锁的注意事项
1. 不要重复锁定互斥锁
2. 不要忘记解锁互斥锁, 必要时使用defer语句
3. 不要对尚未锁定或者已解锁的互斥锁解锁
4. 不要在多个函数之间直接传递互斥锁.

go运行时系统自行抛出的panic都属于致命错误, 都是无法被恢复的, 调用recover函数对它们起不到任何作用.
一旦产生死锁, 程序必然崩溃. 一个goroutine对某一个互斥锁的重复锁定, 意味着它自己锁死了自己. 先不
说这种做法本身就是错误的, 此情况下, 想让其他的goroutine来帮它解锁是非常难以保证其正确性的.

解锁未锁定的互斥锁会立即引发panic.
应该总是保证, 对于每一个锁定操作, 都要有且只有一个对应的解锁操作.

sync.Mutex类型是结构体类型, 属于值类型, 将其传递给一个函数、将它从函数中返回、赋值给其他变量、
让它进入某个通道都会导致副本的产生, 且原值和它的副本以及多个副本之间都是完全独立的, 是不同的互斥
锁.

** 读写锁与互斥锁的异同
读写锁是读/写互斥锁的简称, 在Go语言中, 读写锁由sync.RWMutex类型的值代表, 与sync.Mutex类型一致.
读写锁把对资源的"读","写"操作区别对待了. 可以对这两种操作施加不同程度的保护.

RWMutex的Lock与UnLock分别用于对写锁进行操作, RLock,RUNlock用于对读锁进行操作.
对于同一个读写锁来说有如下规则:
1. 在写锁已被锁定的情况下再试图锁定写锁, 阻塞当前的goroutine
2. 在写锁已被锁定的情况下再试图锁定读锁, 阻塞当前的goroutine
3. 在读锁已被锁定的情况下试图锁定写锁, 阻塞当前的goroutine
4. 在读锁已被锁定的情况下试图锁定读锁, 不会阻塞当前的goroutine
总结起来就是: 对于某个受到读写锁保护的共享资源, 多个写操作不能同时进行, 写操作和读操作不能同时
进行, 但多个读操作是可以的.

Go语言中读写锁的写操作之间的互斥是通过内含一个互斥锁实现的, 即Go中读写锁是互斥锁的一种扩展.
解锁"读写锁中未被锁定的写锁", 会立即引发panic, 对于其中的读锁也是一样的.

* sync.Cond
** 基础
sync.Cond是条件变量, 条件变量是基于互斥锁的, 必须有互斥锁的支撑才能发挥作用. 不是被用来保护临界
区和共享资源的, 是用于协调想要访问共享资源的那些线程的. 当共享资源的状态发生变化时, 可以被用来
通知被互斥锁阻塞的线程.

一个模拟场景就是: 两个人共同执行一项秘密任务, 需要在不直接联系和见面的前提下进行. 一个需要
向一个信箱里放置情报, 一个需要取情报, 如果在放置的时候发现信箱未取走那就先不放置, 而先返回.
如果在获取的时候没有情报, 也先返回. 虽然各自都有信箱的钥匙, 但同一时刻只能有一个人插入钥匙并打开
信箱, 这就是锁的作用.

如果信箱里有情报, 却迟迟未取走, 那就需要每过一段时间带着新情报去检查一次, 另一方如果信箱里一直
没有情报, 也需要每过一段时间去打开看看, 一旦有了情报就及时地取走. 这种实现方式不太好. 后来有人
设计了一个计策, 如: 各自雇佣一个不起眼的小孩儿, 如果早上7点有个戴红色帽子的小孩从楼下经过, 就
意味着信箱里有了新情报, 另一边如果上午9点有一个带蓝色帽子的小孩儿从我家楼下路过, 就说明已经从
信箱中取走了情报.
这两个带不同颜色帽子的小孩儿就相当于条件变量, 在共享资源的状态产生变化时, 起到了通知的作用.

条件遍历在程序中的最大优势就是在效率方面的提升, 当共享资源的状态不满足条件的时候, 想操作它的线程
再也不用循环往复的检查了, 只要等待通知就好了.

** 条件变量与互斥锁配合使用
条件变量的初始化离不开互斥锁, 并且它的方法用的也是基于互斥锁的.

条件变量提供的方法有3个: 等待通知(wait), 单发通知(signal)和广播通知(broadcast).
在利用条件变量等待通知的时候, 需要在它基于的那个互斥锁保护下进行, 而在进行单发通知或广播通知的
时候, 恰恰相反, 需要在对应的互斥锁解锁之后再做这两种操作.

示例代码如下:
#+BEGIN_SRC go
func main() {
    var mailbox uint8
    var lock sync.RWMutex
    sendCond := sync.NewCond(&lock)
    receCond := sync.NewCond(lock.RLocker())

    sign := make(chan struct{}, 3) // 与主进程通信的信号
    max := 5

    go func(max int){ // 信号发送者
        for i:=1; i<=max; i++ {
            time.Sleep(time.Millisecond*500) // 模拟其他的处理情况
            lock.Lock()
            for mailbox == 1 {
                fmt.Printf("mailbox is full, sender wait\n")  // 只会输出一行数据, 原因见下
                sendCond.Wait()  // 消息不空, 需等待
            }
            fmt.Printf("sender [%d]: the mailbox is empty.", i)
            mailbox = 1
            lock.Unlock()
            receCond.Signal()  // 通知消息接受端
        }
    }(max)

    go func(max int){
        for i:=1; i<=max; i++ {
            time.Sleep(time.Second)  // 模拟其他的处理情况
            lock.RLock()
            for mailbox == 0 {
                receCond.Wait()
            }
            fmt.Println("recevier has msg")
            mailbox = 0
            lock.RUnlock()
            sendCond.Signal()
        }
    }(max)

    <- sign
    <- sign
}
#+END_SRC

** 对于以上代码的疑问
1. 条件变量的Wait方法做了什么, 为什么要先锁定条件变量基于的互斥锁, 才能调用它的wait方法,
   为什么要用for语句来包裹调用条件变量的Wait方法.
   
   条件变量的Wait方法主要做了四件事:
   a. 把调用它的goroutine加入到当前条件变量的通知队列中
   b. 解锁当前的条件变量基于的那个互斥锁
   c. 让当前的goroutine处于等待状态, 等到通知到来的时候再决定是否唤醒它, 此时该goroutine就会阻塞
      在调用这个Wait方法的那行代码上
   d. 如果通知到来并且决定唤醒这个goroutine, 就在唤醒它之后重新锁定当前条件变量基于的互斥锁.
      自此之后, 当前的goroutine就会继续执行后面的代码
      
   使用for的原因是: if语句只会对共享资源的状态检查一次, 而for语句却可以做多次检查, 直到这个状态
   改变为止. 多次检查的原因是: 为了保险起见, 如果一个goroutine因收到通知而被唤醒, 但却发现共享
   资源的状态依然不符合要求, 那么应该再次调用条件变量的Wait方法, 并继续等待下次通知的到来.
   这种情况很有可能发生, 如下:
   1. 有多个goroutine在等待共享资源的同一种状态, 如: 它们都在等mailbox变量的值不为0的时候再把它
      的值变为0, 这就相当于有多个人在等着信箱里的情报, 但每次成功的goroutine却只能有一个, 条件
      变量的Wait方法会在当前的goroutine醒来后先重新锁定那个互斥锁, 在成功的goroutine最终解锁
      互斥锁之后, 其他的goroutine会先后进入临界区, 但他妈发现共享资源的状态依然不是它们想要的,
      此时for循环就很有必要了
   2. 共享资源可能有的状态不是两个, 而是多个, 如: mailbox变量的可能值不只有0和1, 还有其他情况.
      所以在设计合理的前提下, 单一的结果一定不可能满足所有goroutine的条件, 未被满足的goroutine
      显然还需要等待和检查
   3. 有一种可能, 共享资源的状态只有两个, 并且每种状态都只有一个goroutine在关注, 如上代码. 在
      一些多CPU核心的计算机系统中, 即使没有收到条件变量的通知, 调用其Wait方法的goroutine也是
      有可能被唤醒的, 这是由计算机硬件层面决定的, 即使是操作系统本身的条件变量也会如此.
   
2. 条件变量的Signal方法和Broadcast方法的异同
   Signal只会唤起一个等待的goroutine, Broadcast会唤醒所有为此等待的goroutine. 条件变量的Wait方法
   总会把当前的goroutine添加到通知队列的队尾, Signal方法总会从通知队列的队首开始查找可被唤醒的
   goroutine. 因此唤醒的goroutine一般都是最早等待的那一个.

   Signal和Broadcast方法不需要在互斥锁的保护下执行, 恰恰相反, 最好是在释放条件变量基于的那个锁
   之后, 再去调用它们, 这更有利于程序的运行效率.

   条件变量的通知具有及时性, 如果发送通知的时候没有goroutine为此等待, 则该通知就会被直接丢弃.
   在这之后才开始等待的goroutine只可能被后面的通知唤醒

* sync.atomic - 原子操作
** 基础
中断的时机有很多, 任何两条语句执行的间隙, 甚至在某条语句执行的过程中都是尅的, 即使这些语句在临界
区内也是如此. 互斥锁虽然可以保证临界区中代码的串行执行, 但却不能保证这些代码执行的原子性
(atomicity).

能够保证原子性执行的只有原子操作(atomic operation). 在底层这会由CPU提供芯片级别的支持, 绝对有效.
即使在拥有多CPU核心, 或者多CPU的计算机系统中, 原子操作的保证也是不可撼动的.

原子操作不能被中断, 所以要足够简单, 并且要求快速. 因此操作系统层面只对二进制位或整数的原子操作
提供了支持.

GO语言的原子操作是基于CPU和操作系统的, 所以也只针对少数数据类型的值提供原子操作函数, 都在
sync/atomic中.

sync/atomic包中的函数可以做的原子操作有: 加法(add), 比较并交换(compare and swap, 简称CAS),
加载(load), 存储(store), 交换(swap).

这些函数针对的数据类型不多, 对这些类型中的每个, sync/atomic包都会有一套函数给予支持. 这些数据
类型有: int32, int64, uint32, uint64, uintptr, unsafe.Pointer.
unsafe.Pointer并未提供进行原子加法操作的函数.

此外, sync/atomic包还提供了Value类型, 可以被用来存储任意类型的值.

** 一些注意的问题
1. 传入这些原子操作函数的第一个参数都是指针, 原因是:
   因为原子操作函数需要的是被操作值的指针, 而不是这个值本身, 被传入函数的参数值都会被复制,
   基本类型的值一旦传入函数, 就已经与函数外的那个值无关系了
   
   传入值本身没有任何意义, unsafe.Pointer类型虽然是指针类型, 但那些原子操作函数要操作的是这个
   指针值, 而不是它指向的值, 所以任然需要指向这个指针值的指针.
2. 用原子加法操作的函数可以做原子减法吗
   可以, 如: atomic.AddInt32函数的第二个参数代表差量, 其类型是int32, 是有符号的. 做减法时, 将
   差量设置为负数即可.

   对于atomic.AddUint32就不能这么直接, 因为第二个参数的类型是无符号的, 但也可以做到, 稍微麻烦
   一些. 如下:
   如果想对uint32类型的被操作值18做原子减法, 比如差量为-3, 可以先把这个差量转为为有符号的int32
   的值, 然后再把该值的类型转换为uint32, 即:
   delta := -3; var d uint32 = 18; atomic.AddUint32(&d, uint32(delta))
   
   或者依据公式^uint32(-N-1), N表示由负整数表示的差量, 即先把差量的绝对值减去1, 然后再把得到
   的这个无类型的整数常理转换为uint32类型的值, 最后在这个值之上做按位异或操作, 就可以获得最终
   的参数值, 该表达式的结果的补码值与使用前一种方法得到的值的补码相同.
3. 比较并交换与交换操作的区别
   比较并交换操作即CAS操作, 是有条件的交换操作, 只有在满足条件的情况下才会进行值的交换.
   
   所谓的交换指的是, 把新值赋给变量, 并返回变量的旧值. CAS操作时, 函数会先判断被操作变量的当前
   值是否与我们预期的旧值相等, 如果相等, 就把新值赋给该变量, 并返回true以表明交换操作已进行,
   否则就忽略交换操作, 并返回false.

   将CAS与for语句联用就可以实现一种简单的自旋锁(spinlock). 如:
   for {
       if atomic.CompareAndSwapInt32(&num, 10, 0) { // 如果num的值为10, 则将其赋值为0
           break
       }
   }
   这在效果上与互斥锁有些类似, 它们的适用场景是不同的.
   for语句加CAS操作的假设往往是: 共享资源状态的改变并不频繁, 或它的状态总会变成期望的那样.
4. 假设已经保证了对一个变量的写操作是原子操作, 那对其进行读操作的时候, 需要使用原子操作吗
   很有必要. 如果写操作还没有写完, 读操作就来读了, 那么就只能读到仅修改的部分值. 这就破坏了
   值的完整性, 读出来的值也是完全错误的.

   一旦决定要对一个共享资源进行保护, 则一定要做到完全的保护. 不完全的保护基本上与不保护没有
   什么区别.

** atomic.Value
GO 1.4+版本发布的时候增加的. 此类型的值相当于一个容器, 可以被用来"原子地"存储和加载任意的值.
开箱即用的, 声明一个该类型的变量之后就可以直接使用了. 只有两个指针方法Store和Load.

注意:
1. 一旦atomic.Value类型的值被真正使用, 它就不应该再被复制了.
   即用它来存储值了, 该类型属于结构体类型, 是值类型.
   
   用原子值来存储值有两条强制性的使用规则: 第一条规则, 不能用原子值存储nil, 否则在调用Store方法
   时, 会引发一个panic.
   
   如果一个接口类型的变量, 它的动态值是nil, 但动态类型却不是nil, 则它的值不等于nil. 是可以存入的
2. 向原子值存储的第一个值, 决定了它今后能且只能存储哪一个类型的值
   可能会想: 先存储一个接口类型的值, 然后在存储这个接口的某个实现类型的值, 这样是不可以的.
   因为原子值内部是依据被存储值的实际类型来做判断的.

   无法通过某个方法获知一个原子值是否已经被真正使用, 并且, 也没有办法通过常规的途径得到一个原子
   值可以存储值的实际类型.

使用原子值的建议:
1. 不要把内部使用的原子值暴露给外界. 比如: 声明一个全局的原子变量并不是一个正确的做法.
2. 如果不得不让包外或模块外的代码使用你的原子值, 那么可以声明一个包级使用的原子变量, 然后通过
   公开函数让外界间接的使用到它. 此时不要将原子值传递到外界不论是传递原子值还是它的指针值》
3. 如果通过某个函数可以向内部的原子值存储值的话, 那么就应该在这个函数中先判断被存储值类型的合法
   性, 若不合法, 就返回对应的错误, 从而避免panic
4. 如果可能的话, 可以把原子值封装到一个数据类型种, 比如一个结构体类型. 这样即可以通过该类型的方法
   更安全的存储值, 又可以在该类型种包含可存储值的合法类型信息.
5. 尽量不要向原子值中存储引用类型的值, 因为这很容易照成安全漏洞. 如:
   var box6 atomic.Value
   v6 := []int{1, 2, 3}
   box6.Store(v6)
   v6[1] = 4  // 此处的操作不是并发安全的, 在外边改动了这个切片的值, 就等于修改了box6中存储的值
   这相当于绕过了原子值而进行了非并发安全的操作. 可以改为如下方式:
   store := func(v []int) {
       replica := make([]int, len(v))
       copy(replica, v)
       box6.Store(replica)
   }
   store(v6)
   v6[2] = 5  // 此处的操作是安全的

* sync.WaitGroup
** 基础
WaitGroup类型是一种比通道更加适合实现这种一对多的goroutine协作流程. 该类型是开箱即用的,
并发安全的, 一旦被真正使用就不能被复制了. 拥有3个指针方法: Add, Done, Wait. 可以想象该类型中有
个计数器, 其默认值为0. 可以通过调用该类型值的Add方法来增加或者减少这个计数器的值.

一般情况下可以使用这个方法来记录需要等待的goroutine的数量. Done方法用于对其所属值计数器的值进行
减一操作. 可以在需要等待的goroutine中, 通过defer语句调用它. Wait方法的功能是, 阻塞当前的goroutine
直到其所属值中的计数器归零. 如果在该方法被调用时, 计数器的值为0, 则什么也不会做.
#+BEGIN_SRC go
func addNum(numP *int32, id, max int32, deferFunc func()) {
    defer func() {
        deferFunc()
    }()
    // ...
}

func coordinateWaitGroup() {
    var wg sync.WaitGroup
    wg.Add(2)

    num := int32(0)
    max := int32(10)
    
    go addNum(&num, 3, max, wg.Done)
    go addNum(&num, 4, max, wg.Done)
    wg.Wait()
}
#+END_SRC

** 常见问题
1. sync.WaitGroup类型值中计数器的值可以小于0吗
   不可以. 小于0时会引发一个panic. 不适当的调用这类值的Done和Add方法都会如此. 调用Add时可以传入
   一个负数的.

   WaitGroup值是可以被复用的, 但需要保证其计数周期的完整性. 即计数器的值始于0又归为0, 就可以被
   视为一个计数周期.

   不要将增加其计数器值的操作和调用其Wait方法的代码, 放在不同的goroutine中执行

* sync.Once
** 基础
属于结构体类型, 开箱即用和并发安全. 该类型种包含了一个sync.Mutex类型的字段. 复制该类型的值也会
导致功能的失效.

Do方法只接受一个参数, 该参数的类型必须是func(). 即无参数声明和结果声明的函数. 该方法的功能并不是
对每一种参数函数都只执行一次, 而是只执行"首次被调用时传入的"那个函数, 并且之后不会再执行任何参数
函数.

如果有多个只需要执行一次的函数, 那么就应该为它们中的每一个都分配一个sync.Once类型的值.
Once类型种还有一个名叫done的uint32类型的字段, 其作用是记录其所属值的Do方法被调用的次数. 该值只
可能是0或1. 一旦Do方法的首次调用完成, 它的值就会从0变为1.
done使用uint32的原因是: 对其操作必须是"原子"的.

Do方法的执行流程大致为:
一开始就会通过调用atomic.LoadUint32函数来获取该字段的值, 并且一旦发现该值为1就会直接返回. 这初步
保证了"Do"只会执行首次被调用时传入的函数. 但此保证还是不足够的. 如果有两个goroutine都调用了同
一个新的Once值的Do方法, 并且几乎同时执行到了其中的这个条件判断代码, 那么会因为判断结果为false而
继续执行Do方法中剩余的代码. 在这个条件判断之后, Do方法会立即锁定其所属值中的那个sync.Mutex类型的
字段m, 然后会在临界区中再次检查done字段的值, 并且仅在条件满足时才会去调用参数函数, 以及用原子操作
把done的值变为1.

这种方式与GoF设计模式中的单例模式很相似, 都会在临界区之外判断一次关键条件, 若条件不满足则立即返回
这叫做"快路径", 或者"快速失败路径".
如果条件满足, 到了临界区中还要再对关键条件进行一次判断, 这主要是为了更加严谨, 这两次判断常被统称
为(跨临界区的)"双重检查". 进入临界区之前, 肯定要锁定保护它的互斥锁m, 会降低执行速度, 所以其中的
第二次判断以及后续的操作就被称为"慢路径"或者"常规路径".

** Do方法的特点
1. 由于Do方法只会在参数函数执行结束后将done字段变为1, 如果参数函数的执行需要很长时间或者根本不会
   结束(如守护任务), 那么就有可能会导致其他相关goroutine同时阻塞
2. Do方法在参数函数执行完之后, 会在defer语句中对done值进行原子赋值操作. 不论函数参数的执行的执行
   会以怎样的方式结束, done字段的值都会变为1.
   即使该函数没有执行成功(如引发panic), 也无法使用同一个Once值重新执行它. 如果需要为参数函数的
   执行设定重试机制, 那么就要考虑Once值的适时替换问题.

* context.Context
** 基础
Context是在go 1.7+加入的.
如果不能在一开始就确定执行子任务的goroutine的数量, 则使用WaitGroup值来协调它们和分发子任务的
goroutine就是有一定的风险, 一个解决方案是: 分批的启用执行子任务的goroutine.

#+BEGIN_SRC go
func coordinateWaitGroup() {
    total := 12
    stride := 3
    var num int32

    var wg sync.WaitGroup
    for i := 1; i <= total; i = i+stride {
        wg.Add(stride)
        for j := 0; j<stride; j++ {
            go addNum(&num, i+j, wg.Done)
        }
        wg.Wait()
    }
}
#+END_SRC

** 使用context包中的函数实现一对多的goroutine协作流程
#+BEGIN_SRC go
func coordinateWithContext() {
    total := 12
    var num int32
    // cxt是一个可撤销的context.Context类型的值
    // cancelFunc是context.CancelFunc类型的撤销函数
    cxt, cancelFunc := context.WithCancel(context.Background())
    for i:=1; i<=total; i++ {
        go addNum(&num, i, func() {
            // 如果所有的addNum函数都执行完毕, 那么立即通知分发子任务的goroutine
            if atomic.LoadInt32(&num) == int32(total) {
                cancelFunc()
            }
        })
    }
    <-cxt.Done()
}
#+END_SRC
代码解释: for语句中, 每次迭代都通过go语句异步的调用addNum函数, 调用的总次数只依据total变量的值.
addNum传入的函数中只包含了一条if语句, 这条if语句会"原子"地加载num的值, 并判断是否与total相等.
如果相等就调用cancelFunc函数, 其含义是如果所有的addNum函数都执行完毕, 那么立即通知分发子任务的
goroutine, 此处分发子任务的goroutine即为执行coordinateWithContext函数的goroutine. 它在执行完
for后, 会立即调用cxt变量的Done函数, 并试图针对该函数返回的通道, 进行接收操作.

由于一旦cancelFunc函数被调用, 针对该通道的接受操作就会马上结束, 所以这样做可以实现"等待所有的"
addNum函数都执行完毕的功能.

** 进阶
Context类型受到了标准库中众多代码包的积极支持, 主要是因为它是一种非常通用的同步工具, 其值可以
被任意扩散, 也可以被用来传递额外的信息和信号.

Context类型可以提供一类代表上下文的值, 此类值是并发安全的, 可以被传播给多个goroutine.
Context类型实际上是一个接口类型, context包中实现该接口的所有私有类型都是基于某个数据类型的指针
类型, 因此传播并不会影响该类型值的功能和安全.

Context类型的值是可以繁衍的, 这意味着我们可以通过一个Context值产生出任意个子值. 这些子值可以携带
其父值的属性和数据, 也可以响应通过其父值传达的信号.

所有的Context值共同构成了一颗代表了上下文全貌的树形结构, 这棵树的树根是一个已经在context包中预先
定义好的Context值, 是全局唯一的. 通过调用context.Background获取它.
该上下文根节点仅仅是一个最基本的支点, 不提供任何额外的功能, 即不可以被撤销, 也不能携带任何数据.

context包中包含了4个用于繁衍Context值的函数, 即: WithCancel, WithDeadline, WithTimeout和WithValue
这些函数的第一个参数类型都是Context, 参数名为parent, 即该位置上的参数对应的都是它们将会产生的
Context值的父值.

WithCancel用于产生一个可撤销的parent的子值
WithDeadline, WithTimeout函数则都可以被用来产生一个会定时撤销的parent的子值.
WithValue 产生一个会携带额外数据的parent的子值.

1. "可撤销的"在context包中代表什么, "撤销"一个Context值又意味着什么
   Context接口中有两个方法与"撤销"有关, Done方法会返回一个元素类型为struct{}的接受通道,
   该接受通道的用途不是传递元素值, 而是让调用方感知"撤销"当前Context值的那个信号

   一旦当前的Context值被撤销, 此处的接收通道就会被立即关闭, 对于一个未包含任何元素值的通道来说
   它的关闭会使任何针对它的接收操作立即结束.
   
   Context类型的Err方法, 该方法的结果是error类型的, 且其值只可能等于context.Canceled变量的值或者
   context.DeadlineExceeded变量的值. 前者表示手动撤销, 后者表示给定的时间已到, 而导致的撤销.
2. 撤销信号是如何在上下文树中传播的
   在撤销函数被调用后, 对应的Context值会先关闭它内部的接收通道, 然后会向它的所有子值传达撤销信号
   子值也会如法炮制, 把撤销信号继续传播下去. 最后该Context值会断开它与其父值之间的关联.

   context.WithValue函数得到的Context值是不可撤销的, 撤销信号在被传播时, 若遇到它们则会直接跨过
   并试图将信号直接传递给它们的子值.
3. 怎样通过Context值携带数据, 如何从中获取数据
   WithValue函数需要三个参数: 父值、键和值. 此处的键必须是可判等的
   Context类型的Value方法就是被用来获取数据的. 会先判断给定的键是否与当前值中存储的键相等, 如果
   相等就把该值中存储的值直接返回, 否则就到其父值中继续查找. 除了含数据的Context值以外, 其他
   几种Context值是无法携带数据的, 在沿路查找值的时候, 会直接跨过那几种值.
