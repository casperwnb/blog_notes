* Go的辅助工具包
go get golang.org/x/tools/cmd/goimports  # 根据需要自动添加或删除import声明

* Go 基础
** 不需要添加分号
不需要在语句或声明的末尾添加分号, 除非一行上有多条语句. 编译器会主动把特定符号后的换行符转换为
分号, 因此换行符添加的位置会影响Go代码的正确解析.

例如: x + y, 可在+后换行, 不能在"+"前换行.

** ++, --
go中++和--是语句, 不是表达式, 因此不能用于赋值.

** for
for init; condition; post {
}

for的这三个部分都可以省略或省略部分. condition是一个布尔表达式, 其值在每次循环迭代开始时计算.

** printf格式
fmt.Printf的转换格式定义:
| %d         | 十进制整数                               |
| %x, %o, %b | 16, 8, 2进制整数                         |
| %f, %g, %e | 浮点数                                   |
| %t         | 布尔: true/false                         |
| %c         | 字符(rune)unicode码点                    |
| %s         | 字符串                                   |
| %q         | 带双引号的字符串"abc"或带单引号的字符'c' |
| %T         | 变量的类型                               |
| %%         | 输出百分号标志                           |
| %#         |                                          |
#+BEGIN_SRC go
// %[1]表示使用第一个操作数, 即10
// %#表示在使用%o, %x或%X时输出时生成0, 0x, 0X前缀
fmt.Printf("%d, %[1]o, %#[1]x\n", 10)

// 打印8个字符宽度, 小数点后3个字符宽度, 如果不足8个字符宽度, 会使用空格填充,
// 超过8个字符则不会截断
fmt.Printf("%8.3f\n", 1.334567)
fmt.Printf("%08b\n", 10)  // 不足8位时使用0补齐
#+END_SRC
** switch
go中的switch不需要显式的在每一个case后写break, 语言默认执行完case后的逻辑语句会自动退出.
如果在一个case语句下, 不想执行后面的内容, 则可以使用break语句.
#+BEGIN_SRC go
func main() {
	a := 1
	switch a {
	case 1:
		fmt.Println("case 1")
		if false {
			fmt.Println("no through")
			break
		}
		fallthrough
	case 2:
		fmt.Println("case 2")
	}

    // 另一种switch格式, 无tagswitch, 与switch true等价
	switch {
	case a == 1:
		fmt.Println("a == 1")
	}
}
#+END_SRC
如果想相邻的几个case都执行同一逻辑, 可以显示的加上fallthrough, 必须加在每个case的最后位置.

** break/continue
#+BEGIN_SRC go
func main() {
loop:
	for i := 0; i < 10; i++ {
		if i == 2 {
			continue loop  // 跳转到loop继续执行
            // break loop  // 跳转到loop后的代码继续执行
		}
		fmt.Println(i)
	}
	fmt.Println("Loop after")
}
#+END_SRC
** 指针
go可以是&返回一个变量的地址, *可以获取指针指向的变量内容, 但没有指针运算.

** go doc
go doc http.ListenAndServe  # 在本地查看ListenAndServe的注释信息

在需要导出的函数前写注释:
// <funcName> xxx
func funcName() {}

** 变量
go会对每个未赋值的变量使用"零值"初始化, 这可以确保每个声明的变量总是有一个良好定义的值.
在包级别声明的变量会在main入口函数执行前完成初始化, 局部变量将在声明语句被执行到的时候完成初始化.

var i, j, k int
var b, f, s = true, 2.3, "four"

简短变量声明语句必须至少要包含一个新的声明, 并且旧变量的类型不能变化.

go中返回函数中局部变量的地址是安全的.

编译器会自动选择在栈上还是堆上分配局部变量的存储空间, 但这个选择并不是由var还是new
声明变量的方式决定的.

math.Nan()返回一个非数对应的值, 是float64类型的, 可以使用math.IsNaN来测试一个数是否是非数.
在浮点数中, NaN, 正无穷和负无穷都不是唯一的, 每个都有非常多的bit模式表示.

** new
new(T)将创建一个T类型的匿名变量, 初始化为T类型的零值, 然后返回变量地址, 返回的指针类型为*T.

如果两个类型都是空的, 即类型的大小是0, 如: struct{}和[ 0]int, 有可能有相同的地址(依赖具体的语言
实现, 并且也可能导致Go语言的自动垃圾回收器有不同的行为, 查看runtime.SetFinalizer相关信息).

** 类型
具有相同底层类型的类型是不同的数据类型, 不能相互比较或混在一个表达式运算中.
#+BEGIN_SRC go
type Celsius float64  // 摄氏温度
type Fahren float64  // 华氏温度

var t Celsius
Fahren(t)  // 类型转换, 不是函数调用
#+END_SRC
类型转换不会改变值本身, 但会使它们的语义发生变化. 对于每一个类型T, 都有一个类型转换操作T(x), 用于
将x转换为T类型, 如果T是指针类型可能会需要用小括号包装, 如(*int)0.

只有当两个类型的底层基础类型相同时才允许这种转型操作, 或者是两者都指向相同底层结构的指针类型.
将一个字符串转为[]byte类型的slice将拷贝一个字符串数据的副本.

任何情况下, 运行时不会发生转换失败的错误, 错误只会发生在编译阶段.

** 包
如果包中含有多个.go源文件, 他们将按照发给编译器的顺序进行初始化, go构建工具会先将go文件根据文件
名排序, 然后依次调用编译器编译.

#+BEGIN_SRC go
var pc [256]byte = func() (pc [256]byte) {
    for i:= range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
    return
}()  // 直接定义值
#+END_SRC

包变量会被函数中的局部变量隐藏, 例如:
#+BEGIN_SRC go
var cwd string

func init() {
    cwd, err := os.Getwd()  // 此处不会使用全局的cwd, 可以使用go vet -shadow main.go检查
}
#+END_SRC

** unicode字符
unicode字符是rune类型, 是和int32等价的类型, 用于表示一个unicode码点.
UTF8使用1~4个字节来表示每个Unicode码点, 每个符号编码后第一个字节的高端bit位用于表示
总共有多少个编码字节, 如果第一个字节的高端bit为0, 则表示对于7bit的ASCII字符. 如果第一个字节的高端
bit是110, 则说明需要两个字节, 后续的每个高端bit都以10开头, 如下:
| 0xxxxxxx                            |    runes 0-127 | ASCII                |
| 110xxxxx 10xxxxxx                   |       128-2047 | values < 128 unused  |
| 1110xxxx 10xxxxxx 10xxxxxx          |     2048-65535 | values < 2048 unused |
| 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx | 65535-0x10ffff | other values unused  |

UTF8编码是一个前缀编码, 与Unicode的码点顺序一致, 可以直接排序UTF8编码序列. 应为没有嵌入的NUL(0)
字节, 可以很好的兼容那些使用NUL作为字符串结尾的编程语言.

#+BEGIN_SRC go 操作Unicode
s := "Hello, 世界"
b := []byte(s)  // 转换为字节slice
fmt.Println(utf8.RuneCountInString(s))

for i:=0; i<len(s); {
    r, size := utf8.DecodeRuneInString(s[i:])  // r表示rune字符本身, size表示该字符占用的字节数
    fmt.Printf("%d\t%c\n", i, r)
    i += size
}

for i, r := range s {
    fmt.Println(i, r)
}
#+END_SRC
如果遇到一个错误的UTF8编码输入, 将生成一个特别的unicode字符"\uFFFD".
将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串.

** 操作符
取模运算符仅用于整数, 其符合与被取模运算符的符号一致.

&^: 位清空(AND NOT).
z = x &^ y: 如果y中对应的bit位为1, 则z中的对应为为0, 其他情况保持不变.

** 内置len函数返回有符号数的一种合理解释
例如:
#+BEGIN_SRC go
medals := []string{"gold", "silver"}
for i := len(medals) - 1; i >= 0; i-- {
    fmt.Println(medals[i])
}
#+END_SRC
如果len返回一个无符号数, 则i >= 0会永远成立, 这样就会超出数组的访问范围从而引发panic.

** 字符串
len返回字符串的字节数目, 不是rune字符数目.
字符串操作s[i:j]基于原始的s字符串生成一个新字符串.
#+BEGIN_SRC go 想法验证
s := "I Love Candice"
a := s[1:2]
b := s[1:2]
#+END_SRC

** 常量
常量可以是构成类型的一部分, 如指定数组类型的长度.
const (
    a = 1
    b  // b = 1
    c = 2
)

** iota常量生成器
在第一个声明的常量所在行, iota会被初始化为0.
const (
    _ = 1 << (10 * iota)
    Kib  // 1024
    Mib  // 1048576
    Gib
    Tib  // (exceeds 1 << 32), 超过了 1 << 32
    Pib
    Eib
    Zib  // 此时直接输出会报错
    Yib
)

fmt.Println(Zib)  // 编译错误, 溢出
fmt.Println(Yib/Zib)  // 正常输出

** 无类型常量
go中许多常量并没有一个明确的基础类型, 编译器为这些没有明确的基础类型的数字常量提供比基础类型更
高精度的算术运算, 可以认为至少有256bit的运算精度.

除法运算符会根据操作数的类型生成对应类型的结果, 因此不同写法的常量除法表达式可能对应不同的结果.
var f float64 = 212
fmt.Printf("%T\n", (f-32)*5/9)  // 100, (f-32)*5 is float64
fmt.Printf("%T\n", 5/9*(f-32))  // 0, 5/9 is an untyped integer = 0
fmt.Printf("%T\n", 5.0/9.0*(f-32))  // 5.0/9.0 is an untyped float

** 数组
r := [...]int{99:-1}  // 前99个元素的值是默认的0, 第100个元素的值为-1.

如果一个数组的元素类型是可以相互比较的, 那么数组类型也是可以相互比较的.
#+BEGIN_SRC go
a := [...]int{1, 2}
b := [2]int{1, 2}
fmt.Println(a==b)
#+END_SRC

** slice
如果切片操作超出cap(s)的上限将导致一个panic异常, 超出len(s)则意味着扩展了slice.
切片操作对于字符串则生成一个新字符串, 如果x是[]byte的话, 则生成一个新的[]byte.
#+BEGIN_SRC go
data := [...]byte{1, 2, 3, 4}
a := data[1:3]
b := data[1:3]
a[0] = 10
fmt.Println(a, b)  // 此处输出证明a, b还是共享同一个底层数据 #TODO

s := []int{10:10}  // slice也可以按顺序指定初始化值序列,或通过索引和元素值指定
#+END_SRC

slice之间不能进行比较, 即不能使用==来比较两个slice是否含有全部相等元素. 唯一合法比较是与nil比较
标准库提供了bytes.Equal函数来判断两个字节型slice是否相等.

一个零值的slice等于nil, 一个nil值的slice没有底层数组, 但也有非nil值的slice的长度和容量是0的,
如: []int{}或make([]int, 3)[3:], 可以使用[]int(nil)类型转换来生成一个对应类型slice的nil值.

测试一个slice是否为空, 应该使用len(s) == 0来判断, 而不应该是s == nil.

** map
不能对map的元素进行取地址操作. map的迭代顺序是随机的.
map之间也不能进行相等比较, 但可以和nil进行比较.

可以用map实现类似set的功能.
#+BEGIN_SRC go 字典的字典
var graph = make(map[string]map[string]bool)
func addEdge(from, to string) {
    edges := graph[from]
    if edges == nil {
        deges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}
#+END_SRC

** 结构体
go中"."操作的对象可以是结构体对象也可以是结构体的指针对象.
#+BEGIN_SRC go
type Employee struct {
    ID int
    Name string
}

func EmployeeByID() *Employee {
    return &Employee{}
}

func main() {
    EmployeeByID().ID = 1  // 如果该函数不是返回的指针, 则会报错
}
#+END_SRC
改为返回Employee值类型后, 调用函数返回的是值, 并不是一个可取地址的变量.

相邻的成员类型如果相同可以合并到一行书写.
结构体成员的输入顺序也有重要意义. 一个结构体可以同时包含导出和未导出的成员.

一个命名为S的结构体不能再包含S类型的成员, 但可以包含*S指针类型成员.

如果结构体的全部成员都是可以比较的, 那么结构体也是可以比较的.

** 结构体嵌入和匿名成员
匿名成员: 在一个结构体内部可以声明一个成员对应的数据类型而不指名成员的名字.
#+BEGIN_SRC go
type Point struct {
    x, y int
}

type Circle struct {
    Point
    Radius int
}

var c Circle
c.x = 1  // 直接访问匿名成员的变量
c.Point.x = 1 // 也可以访问

cc := Circle{Point{1, 2}, 3}
#+END_SRC

外层结构体不仅仅获得了匿名成员类型的所有成员, 而且也获得了该类型导出的全部方法.
在类型中内嵌匿名字段也可以是一个命名类型的指针, 此时字段和方法会被间接地引入到当前的类型种.

** 函数
函数的类型被称为函数的标识符, go语言没有默认参数值, 也不能通过参数名指定形参.
go中所有的函数参数都是值拷贝传入的, 函数参数将不再是函数调用时的原始变量.
go使用可变栈, 栈的大小按需要增加(初始时很小), 这使得使用递归时不必考虑溢出和安全问题.
#+BEGIN_SRC go
func add1(r rune) rune { return r + 1 }
strings.Map(add1, "HAL")
#+END_SRC

** 错误处理
var Err = errors.New("Error")

** 捕获迭代变量
#+BEGIN_SRC go
var rmdirs []func()

for _, d := range tempdirs() {
    os.MkdirAll(dir, 0755)
    rmdirs = append(rmdirs, func(){ os.RemoveAll(d)})
}

for _, rmdir := range rmdirs {
    rmdir()
}
#+END_SRC
以上代码是错误的, 原因是for循环语句引入了新的词法块, 循环变量d在这个词法块中被声明, 在该循环中
生成的所有函数值都共享相同的循环变量, 需要注意的是: 函数值中记录的是循环变量的内存地址, 而不是
循环变量某一时刻的值, 每一次迭代都会更新d的值, 当删除操作执行时, for循环已经完成, d中存储的值
等于最后一次迭代的值, 因此每次对os.RemoveAll的调用删除都是相同的目录. 修改版:
#+BEGIN_SRC go
for _, d := range tempdirs() {
    dir := d
    rmdirs = append(rmdirs, func(){ os.RemoveAll(dir)})
}
#+END_SRC

可变参数: 在参数列表的最后一个参数类型之前加上省略号"...", 这表示该函数会接受任意数量的该类型参数
#+BEGIN_SRC go
func sum(vals... int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
#+END_SRC

** defer
derfer的执行顺序与声明顺序相反.
处理其他资源时, 可以采用defer机制.
在调试复杂程序时, defer机制也常被用于记录何时进入和退出函数, 例如:
#+BEGIN_SRC go
package main
import (
	"log"
	"time"
)

func bigSlowOperation() {
	defer trace("bigSlowOperation")() // don't forget the extra parentheses
	// ...lots of work...
	time.Sleep(10 * time.Second) // simulate slow operation by sleeping
}

func trace(msg string) func() {
	start := time.Now()
	log.Printf("enter %s", msg)
	return func() { log.Printf("exit %s (%s)", msg, time.Since(start)) }
}

func main() {
	bigSlowOperation()
}
#+END_SRC
注意不要忘记defer语句后的圆括号, 否则本该在进入时执行的操作会在退出时执行, 而本该在退出时执行的
永远不会被执行.

defer语句中的函数会在return语句更新返回值变量后再执行, 又因为在函数中定义的匿名函数可以访问该
函数包括返回值变量在内的所有变量, 所以对你们函数采用defer机制可以观察函数的返回值.
#+BEGIN_SRC go
func double(x int) (result int) {
    defer func() {fmt.Printf("double(%d) = %d\n", x, result)}()
    return x * x
}

func triple(x int) (result int) {
    defer func(){result += x}()  // 通过defer修改最终的reuslt值
    return double(x)
}
#+END_SRC

循环体中的defer语句需要特别注意, 因为只有函数在执行完毕后, 延迟函数才会执行, 下面的代码会导致
系统的文件描述符耗尽, 因为在所有文件都被处理之前, 没有文件会被关闭.
#+BEGIN_SRC go
for _, fname := range filenames {
    f, err := os.Open(fname)
    if err != nil { return err }
    defer f.Close()
}

// 解决方法之一是将循环体中的defer语句移至另外一个函数, 
for _, fname := range filenames {
    if err := doFile(fname); err != nil { return err }
}

func doFile(f string) error {
    f, err := os.Open(f)
    if err != nil { return err }
    defer f.Close()
}
#+END_SRC

在处理文件关闭时, 许多文件系统尤其是NFS, 写入文件时发生的错误会被延迟到文件关闭时反馈.
如果没有检查文件关闭时的反馈信息,可能会导致数据丢失,因此最好不要使用defer机制来关闭某些文件操作.

** panic与recover
#+BEGIN_SRC go
func parse(input string) (s *Syntax, err error) {
    defer func() {
        if p:=recover(); p != nil {
            err = fmt.Errorf("%v", p)
        }
    }
}
#+END_SRC
不加区分的恢复所有的panic异常是不可取的做法, 因为在panic之后, 无法保证包级变量的状态仍然和我们
预期一致. 并且不应该试图去恢复其他包引起的panic, 公有的API应该讲函数的运行失败作为error返回,
而不是panic.

根据panic的类型来选择性的恢复:
#+BEGIN_SRC go
func soleTitle(doc *html.Node) (title string, err error) {
    type bailout struct{}
    defer func() {
        switch p := recover(); p {
            case nil: // no panic
            case bailout{}: //do something
            default: panic(p)
        }
    }()

    panic(bailout{})
}
#+END_SRC

** JSON
json使用\Uhhhh转义数字来表示一个UTF-16编码.
将go语言中的数据转换为JSON的过程叫做编组(marshaling), 通过json.Marshal函数完成.
#+BEGIN_SRC go
type Movie struct {
    Title string
    Year int `json:"released"`
}

var movies = []Movie{
    {Title: "C", Year: 1942},
}
data, err := json.Marshal(movies)
// 每一行的输出前缀和每一个层级的缩进
data, err := json.MarshalIndent(movies, "", " ")

var titles []struct{Title string}
if err := json.Unmarshal(data, &titles); err != nil {
    log.Fatalf("Json unmarshal failed: %s", err)
}
// 获取从http请求来的数据并解析
json.NewDecoder(resp.Body).Decode(&titles)
#+END_SRC

